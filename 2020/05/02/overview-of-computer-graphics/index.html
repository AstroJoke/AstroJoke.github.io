<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="GAMES-101：Modern Computer Graphics, AleXandrite">
    <meta name="description" content="闫令琪老师GAMES101个人向知识点总结">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>GAMES-101：Modern Computer Graphics | AleXandrite</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
        .loading-text{
            font-size: 1.5rem;
    }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
</style>
<script>
(function () {
    const loaded = function(){
        setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="alternate" href="/atom.xml" title="AleXandrite" type="application/atom+xml">
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
        .loading-text{
            font-size: 1.5rem;
    }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
</style>
<script>
(function () {
    const loaded = function(){
        setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script></head>



 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">AleXandrite</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle-o" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Movies</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Books</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Galleries</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">AleXandrite</div>
        <div class="logo-desc">
            
            To share and record something
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle-o"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/musics " style="margin-left:75px";>
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/movies " style="margin-left:75px";>
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>Movies</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/books " style="margin-left:75px";>
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Books</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/galleries " style="margin-left:75px";>
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>Galleries</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/CGPP_cover.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">GAMES-101：Modern Computer Graphics</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">
                                <span class="chip bg-color">图形学</span>
                            </a>
                        
                            <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                                <span class="chip bg-color">基础知识</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="post-category">
                                图形学
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-02
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    106 分
                </div>
                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>GAMES101是闫令琪老师的现代图形学入门，本文是二刷这个mooc的小总结，（flag）拟<del>三天</del>五天<del>（咕咕咕）</del>七天内完成（6天完成了哭哭）。</p>
<p>如果在阅读过程中发现存在错误，欢迎指出（包括但不限于内容错误和语法错误）。</p>
<p>另：封面图取自“MapleStory”（国服为“冒险岛”）的Arcana主城区的游戏内截图，若涉嫌侵权，请联系本人更换封面图。</p>
<p>文章内的部分插图由于一些原因无法显示正在慢慢整理和修改，同时图像名也会在后续的更改中进行更改。</p>
<h2 id="0-Overview-of-Computer-Graphics"><a href="#0-Overview-of-Computer-Graphics" class="headerlink" title="0. Overview of Computer Graphics"></a>0. Overview of Computer Graphics</h2><h3 id="What-is-Computer-Graphics"><a href="#What-is-Computer-Graphics" class="headerlink" title="What is Computer Graphics?"></a>What is Computer Graphics?</h3><p>The use of computers to synthesize and manipulate visual information.</p>
<h3 id="Why-Study-Computer-Graphics"><a href="#Why-Study-Computer-Graphics" class="headerlink" title="Why Study Computer Graphics?"></a>Why Study Computer Graphics?</h3><h4 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h4><ol start="0">
<li><p>Video Games: e.g. “<em>SEKIRO: Shadows Die Twice</em>“,  “<em>Borderlands 3</em>“;</p>
</li>
<li><p>Movies: e.g. “<em>The Matrix（1999）</em>“,”<em>Avatar（2009）</em>“;</p>
</li>
<li><p>Animations: e.g. “<em>Zootopia（2016）</em>“,”<em>Frozen 2（2019）</em>“;</p>
</li>
<li><p>Design: e.g. CAD , CAM ;</p>
</li>
<li><p>Visualization: e.g Science, Engineering, Medicin, Journalism, etc. ;</p>
</li>
<li><p>Virtual Reality &amp; Augemented Reality;</p>
</li>
<li><p>Digital Illustration: e.g. PhotoShop;</p>
</li>
<li><p>Simulation: “<em>Black hole</em>“（simulate the light/ray）,”<em>Dust Bowl phenomena</em>“;</p>
</li>
<li><p>GUI: Graphical User Interfaces;</p>
</li>
<li><p>Typography: Font（about vector or lattice） ;</p>
<p>Rmk: “<em>The Quick Brown Fox Jumps Over The Lazy Dog.</em>“ usually be used in this application because it contain 26 alphabets.</p>
</li>
</ol>
<h4 id="Fundamental-Intellectual-Challenges"><a href="#Fundamental-Intellectual-Challenges" class="headerlink" title="Fundamental Intellectual Challenges"></a>Fundamental Intellectual Challenges</h4><ol start="0">
<li><p>Creates and interacts with realistic virtual world</p>
</li>
<li><p>Requires understanding of all aspects of physical world</p>
</li>
<li><p>New computing methods, displays, technologies</p>
</li>
</ol>
<h4 id="Technical-Challenges"><a href="#Technical-Challenges" class="headerlink" title="Technical Challenges"></a>Technical Challenges</h4><ol start="0">
<li><p>Math of （perspective） projections, curves,surfaces</p>
</li>
<li><p>Physics of lighting and shading</p>
</li>
<li><p>Repressenting/ operating shapes in 3D</p>
</li>
</ol>
<h3 id="Course-Topics"><a href="#Course-Topics" class="headerlink" title="Course Topics"></a>Course Topics</h3><h4 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h4><ol start="0">
<li><p>Project <font color="red">geometry  primitives</font> （3D triangles / polygons） onto the screen;</p>
</li>
<li><p>Break projected primitives into <font color="red">fragments（pixels）</font> ;</p>
</li>
<li><p>Gold standard in Video Games（Real-time Application）.</p>
<p>p.s : Real-time Application: biger than 30 fps.</p>
</li>
</ol>
<h4 id="Curves-and-Meshes"><a href="#Curves-and-Meshes" class="headerlink" title="Curves and Meshes"></a>Curves and Meshes</h4><p>​    How to represent geometry in Computer Graphics</p>
<h4 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h4><ol start="0">
<li><p>Shoot rays from the camera though each pixel;</p>
<ol start="0">
<li>Calculate <font color="red">intersection</font> and <font color="red">shading</font>;</li>
<li><font color="red">Continue to Bounce</font> the rays till they hit light sources.</li>
</ol>
</li>
<li><p>Gold standard in Animations/ Movies（Offline Applications）.</p>
</li>
</ol>
<h4 id="Animation-Simulation"><a href="#Animation-Simulation" class="headerlink" title="Animation / Simulation"></a>Animation / Simulation</h4><ol start="0">
<li><p>Key frame Animation;</p>
</li>
<li><p>Mass-spring System.（弹簧振子系统）</p>
</li>
</ol>
<h3 id="Differences-between-CV-and-CG"><a href="#Differences-between-CV-and-CG" class="headerlink" title="Differences between CV and CG"></a>Differences between CV and CG</h3><p>Everything that needs to be guessed belongs to Computer Verson, and in this MOOC, we don’t introduce it.</p>
<p>“MODEL” use CG（rendering） to “IMAGE”, and “IMAGE” use CV to “MODEL”.”MODEL” usually uesd in CG like modeling, simulation; “IMAGE” usually uesd in CV,like Image Processing.</p>
<p>But CV and CG have not clear boundaries.</p>
<h2 id="1-Linear-Algebra"><a href="#1-Linear-Algebra" class="headerlink" title="1. Linear Algebra"></a>1. Linear Algebra</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ol start="0">
<li><p>Usually written as $\vec a$ or in bold $\bold a$;</p>
</li>
<li><p>Or using start and end points $\vec {AB}=B-A$;</p>
</li>
<li><p>The vector contain direcition and length;</p>
</li>
<li><p>Vector have no absolute starting position（we can see this property in homogeneous coordinate）;</p>
</li>
<li><p>Magnitude（length） of a vector written as $||\vec a||$（二范数，模长等中文名）;</p>
</li>
<li><p>Unit vector （Vector Normalization）</p>
<ol start="0">
<li><p>A vector with Magnitude（length） of 1;</p>
</li>
<li><p>Finding the unit vector of a vector（normalization）:<br>$$<br>\hat a=\frac{\vec a}{||\vec a||}<br>$$<br>$\hat a$ read as “<em>a hat</em>“.</p>
</li>
<li><p>Used to represent directions.</p>
</li>
</ol>
</li>
<li><p>Vector Addition</p>
<ol start="0">
<li><p>Geometrically: Parallelogram la or Triangle law;</p>
</li>
<li><p>Algebraically: Simply add coordinates.</p>
</li>
</ol>
</li>
<li><p>Cartesian Coordinates —笛卡尔坐标系</p>
<p>p.s. The defination of Cartesian Coordinates should get some basic in Set Theorey, Cartesian product. So we pass this defination.</p>
<p>X and Y can be any （usually orthogonal unit ） vectors:<br>$$<br>A=\left(<br>\begin{matrix}<br>x\\<br>y<br>\end{matrix}<br>\right),A^T=(x,y), ||A||=\sqrt{x^2+y^2}<br>$$<br>the symbol $T$  represent the transposition, it is also used in Matrix.</p>
</li>
<li><p>Dot（scalar：标量） Product<br>$$<br>{\vec a} \cdot {\vec b}=||\vec a||||\vec b||cos\theta,cos\theta=\frac{\vec a \cdot\vec b}{||\vec a||||\vec b||}<br>$$</p>
<ol start="0">
<li><p>For unit vector $cos\theta=\hat a\cdot\hat b$.</p>
</li>
<li><p>properties:</p>
<ol start="0">
<li><p>$\vec a \cdot\vec b=\vec b \cdot\vec a$;</p>
</li>
<li><p>$\vec a \cdot （\vec b+\vec c）=\vec a \cdot \vec b+\vec a \cdot \vec c$;</p>
</li>
<li><p>$（k\vec a）\cdot \vec b=\vec a\cdot （k\vec b）=k（\vec a\cdot \vec b ）$;</p>
</li>
<li><p>In artesian Coordinates: Component-wise multiplication ,then adding up（$\vec a=（x_1,x_2,…,x_n）^T,\vec b=（y_1,<br>y_2,…,y_n）^T$）<br>$$<br>\vec a \cdot \vec b=\displaystyle\sum_{i=1}^nx_iy_i<br>$$</p>
</li>
<li><p>Usage: </p>
<ol start="0">
<li><p>Find angle between two vectors:</p>
</li>
<li><p>Finding  <font color="red">projection</font>  of one vector on another:</p>
<p>$\vec b_{\perp}$:projection of $\vec b$ onto $\vec a$.</p>
<ol>
<li>$\vec b_{\perp}=k\hat a$;</li>
<li>$k=||\vec b_{\perp}||=||\vec b||cos\theta$.</li>
</ol>
</li>
<li><p>Measure how close two directions are;</p>
</li>
<li><p>Decompose a vector;</p>
</li>
<li><p>Determine forward（clockwise） / backword（anticlockwise）;</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Cross（vector） product</p>
<ol start="0">
<li><p>Cross product is orthogonal to two initial vectors;</p>
</li>
<li><p>Direction determined by right-hand rule;</p>
</li>
<li><p>Useful in constructing coordinate systems（later）.</p>
</li>
<li><p>properties </p>
<ol start="0">
<li><p>$\vec a  \times \vec b=-\vec b \times \vec a$;</p>
</li>
<li><p>$\vec a \times \vec a= \vec 0$;</p>
</li>
<li><p>$\vec a\times （\vec b+\vec c）=\vec a\times \vec b+\vec a\times \vec  c$;</p>
</li>
<li><p>$\vec a\times（k\vec b）=k（\vec a\times\vec b）$.</p>
</li>
</ol>
</li>
<li><p>Cartsesian Formula<br>$$<br>\vec a\times \vec b=\left(\begin{matrix}y_az_b-y_bz_a\\z_ax_b-x_az_b\\x_ay_b-y_ax_b\end{matrix}\right)<br>$$<br>Later<br>$$<br>\vec a\times \vec b=A^*b=\left(\begin{matrix}0&amp;-z_a&amp;y_a\\z_a&amp;0&amp;-x_a\\-y_a&amp;x_a&amp;0\end{matrix}\right)\left(\begin{matrix}x_b\\y_b\\z_b\end{matrix}\right)<br>$$</p>
</li>
<li><p>Usage</p>
<ol start="0">
<li><p>Determine <strong>left / right</strong>;</p>
</li>
<li><p>Determine <strong>inside / outside</strong> ;</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Orthonormal bases and coordinate frames</p>
<p>it is important for representing points, positions, locations, and many sets of coordinate systems such as Clobal, local ,world, etc. And critical issue is transforming between these systems/bases.</p>
<p>Any set of 3 vectors （in 3D） that （$\vec p$ is projection）<br>$$<br>||\vec u||=||\vec v||=||\vec w||=1\\<br>\vec u \cdot \vec v=\vec v\cdot \vec w=\vec  u \cdot \vec w=0\\<br>\vec w=\vec u \times \vec v（right\space handed）\\<br>\vec p=(\vec p \cdot \vec u)\vec u+(\vec p \cdot \vec v)\vec v+(\vec p \cdot \vec w)\vec w<br>$$</p>
</li>
</ol>
<h3 id="Matrices"><a href="#Matrices" class="headerlink" title="Matrices"></a>Matrices</h3><p>In Graphics, pervasively used to represent transformations （include Translation, Rotation, Shear, Scale）.</p>
<ol start="0">
<li><p>What is a matrix</p>
<ol start="0">
<li>Array of numbers（$m\times n=m\space rows,n\space columns$）</li>
</ol>
<p>$$<br>\left(<br>\begin{matrix}1&amp;3\\5&amp;2\\0&amp;4\end{matrix}\right)<br>$$</p>
<ol>
<li>Addition and multiplication by a scalar are trivial: element by element.</li>
</ol>
</li>
<li><p>Matrix-Matrix Multiplication</p>
<p>if$A\times B$, then the columns in A must =rows in B, namely $（M\times N）（N\times P）=（M\times P）$.</p>
<ol start="0">
<li><p>Element $（i,j）$ in the product is the dot product of row i from A and column j from B.</p>
</li>
<li><p>propertise:</p>
<ol start="0">
<li><p>Generally speaking, the Multiplication is <strong>non-commutative</strong>, namely AB and BA are different <strong>in general</strong>;</p>
</li>
<li><p>Associative and distributive</p>
<ol start="0">
<li><p>$（AB）C=A（BC）$;（can accelarate the speed by dp）</p>
</li>
<li><p>$A（B+C）=AB+AC$;</p>
</li>
<li><p>$（A+B）C=AC+BC$.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Matrix-VectorMultiplication</p>
<ol start="0">
<li><p>Treat vector as a column matrix（$m\times 1$）</p>
</li>
<li><p>Key for transforming points.</p>
</li>
<li><p>Official spoiler: 2D reflection about y=axis<br>$$<br>\left(\begin{matrix}-1&amp;0\\0&amp;1\end{matrix}\right)<br>\left(\begin{matrix}x\\y\end{matrix}\right)<br>=\left(\begin{matrix}-x\\y\end{matrix}\right)<br>$$</p>
</li>
</ol>
</li>
<li><p>Transpose of a Matrix</p>
<ol start="0">
<li><p>Switch rows and columns（$（i,j）\rightarrow（j,i）$）;</p>
</li>
<li><p>$（AB）^T=B^TA^T$.</p>
</li>
</ol>
</li>
<li><p>Identity Matrix and Inverses</p>
<ol start="0">
<li>Identity Matrix:</li>
</ol>
<p>$$<br>I_{3\times3}=\left(\begin{matrix}1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{matrix}\right)<br>$$</p>
<ol>
<li><p>Inverses:</p>
<ol start="0">
<li><p>$AA^{-1}=A^{-1}A=I$;</p>
</li>
<li><p>$（AB）^{-1}=B^{-1}A^{-1}$.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><ol start="0">
<li><p>Why study transformation</p>
<ol start="0">
<li>Modeling </li>
<li>Viewing</li>
</ol>
</li>
<li><p>2D transformations: rotation, scale, shear</p>
<ol start="0">
<li><p>Representing transformations using matrices</p>
</li>
<li><p>The matrix</p>
<ol start="0">
<li><p>Rotation：Suppose rotate about the origin $（0,0）$ ,  anticlockwise by default and rotate angel is $\theta$.So the matrix is :<br>$$<br>R_{\theta}=\left[ \begin {matrix} cos\theta&amp;-sin\theta\\sin\theta&amp;cos\theta\end{matrix}\right]<br>$$<br>$proof:$</p>
<p>​    Get a Cartesian Coordinates $Oxy$, all the vectors, begin from origin, write as $V$.</p>
<p>​    Suppose  we want $\vec {OP}=（x,y）$ rotate to $\vec {OP’}=（x’,y’）$, and $\angle {xOP}=\alpha, \angle{POP’}=\theta$ and $||\vec OP||=r$, we can get the following equations<br>$$<br>\begin{cases}<br>x=rcos\alpha\\<br>y=rsin\alpha\\<br>x’=rcos(\alpha+\theta)\\<br>y’=rsin(\alpha+\theta)<br>\end{cases}<br>$$<br>and then we can get<br>$$<br>\begin{cases}<br>x’=xcos\theta-ysin\theta\\<br>y’=xsin\theta+xcos\theta<br>\end {cases}<br>$$<br>and get the coefficient to the matrix is $R_{\theta}$.</p>
<p>And we can get the<br>$$<br>R_{-\theta}=\left[ \begin {matrix} cos\theta&amp;sin\theta\\-sin\theta&amp;cos\theta\end{matrix}\right]=R_\theta^T<br>$$<br>Infact, if the $detM=1or-1$, we called $M$ is *<em>Orthogonality Matrix *</em>, and $M^{-1}=M^t$</p>
</li>
<li><p>Scale（Non uniform）：Suppose $k_{axis}$ is the scale ratio, so the scale matrix is<br>$$<br>\left[ \begin {matrix}x’\\y’ \end{matrix}\right]=<br>\left[ \begin {matrix} k_x&amp;0\\0&amp;k_y\end{matrix}\right]<br>\left[ \begin {matrix} x\\y\end{matrix}\right]<br>$$</p>
</li>
<li><p>Shear：Suppose horizontal shift is $0$ at $y=0$, horizontal shift is $a$ at $y=1$ and vertical shift is always $0$, so the shear matrix is<br>$$<br>\left[ \begin {matrix}x’\\y’ \end{matrix}\right]=<br>\left[ \begin {matrix} 1&amp;a\\0&amp;1\end{matrix}\right]<br>\left[ \begin {matrix} x\\1\end{matrix}\right]<br>$$</p>
</li>
<li><p>Reflection: To mirror y-axis.<br>$$<br>\left[ \begin {matrix}x’\\y’ \end{matrix}\right]=<br>\left[ \begin {matrix} -1&amp;0\\0&amp;1\end{matrix}\right]<br>\left[ \begin {matrix} x\\y\end{matrix}\right]<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>Linear Transforms = Matrices （of the same dimension）</strong></p>
</li>
<li><p>Homogeneous coordinates</p>
<ol start="0">
<li><p>Why homogeneous coordinates : </p>
<ol start="0">
<li><p>To represent the translation by <strong>linear transforms</strong>;</p>
<ol start="0">
<li><p>The equations of translation<br>$$<br>\begin{cases}<br>x’=x+t_x\\<br>y’=y+t_y<br>\end{cases}<br>$$</p>
</li>
<li><p>If keep the dimension, we only represent it in matrix form<br>$$<br>\left[ \begin {matrix}x’\\y’ \end{matrix}\right]=<br>\left[ \begin {matrix} a&amp;b\\c&amp;d\end{matrix}\right]<br>\left[ \begin {matrix} x\\y\end{matrix}\right]+<br>\left[ \begin {matrix} t_x\\t_y\end{matrix}\right]<br>$$</p>
</li>
<li><p>But we don’t want to be this special case. So we import the homogeneous coordinates</p>
<ol start="0">
<li><p>Add an extra coodinate （w-coordinate）: 2D point =$（x,y,1）^T$ and 2D vector =$（x,y,0）^T$</p>
</li>
<li><p>the the Matrix Representation of translations is<br>$$<br>\left[ \begin {matrix}x’\\y’\\w’ \end{matrix}\right]=<br>\left[ \begin {matrix} 1&amp;0&amp;t_x\\0&amp;1&amp;t_y\\0&amp;0&amp;1\end{matrix}\right]<br>\left[ \begin {matrix} x\\y\\1\end{matrix}\right]=<br>\left[ \begin {matrix} x+t_x\\y+t_y\\1\end{matrix}\right]<br>$$</p>
</li>
</ol>
</li>
<li><p><strong>Tradeoff</strong>: We should consider the extra cost by importing the homogeneous coordinates, because <strong>there is no free lunch in the world</strong>.</p>
</li>
</ol>
</li>
<li><p>To distinguish the vector and the point（ coordinate ）.</p>
<p>we have introduced the homogeneous coordinates, but why we should put the extra dimension to $1$ （in point） or $0$ （in vector）?</p>
<p>Because the vector have the property — translation invariance. So we want, after the transformation, the vector won’t be change.</p>
<p>And the Valid operation if w-coordinate of result is 1 or 0</p>
<ol start="0">
<li><p>vector + vector = vector;</p>
</li>
<li><p>point - point = vector;</p>
</li>
<li><p>point + vector = point ;</p>
</li>
<li><p>point + point = Special Case</p>
</li>
<li><p>Special Case: if the w-coordinate is not both 0 or 1, we let the point normalization. After the normalization, we can get a point. （In the Num 3 operation, we will get the mid point between 2 points）.<br>$$<br>\left[ \begin {matrix}x\\y\\w \end{matrix}\right]=\left[ \begin {matrix}\frac xw\\ \frac yw\\1 \end{matrix}\right],w\neq0<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Affine transformation（仿射变换）</p>
<ol start="0">
<li>Affine map = linear map + translation. So using homogeneous coordinates, we can get</li>
</ol>
<p>$$<br>\left[ \begin {matrix}x’\\y’\\w’ \end{matrix}\right]=<br>\left[ \begin {matrix} a&amp;b&amp;t_x\\c&amp;d&amp;t_y\\0&amp;0&amp;1\end{matrix}\right]<br>\left[ \begin {matrix} x\\y\\1\end{matrix}\right]<br>$$</p>
<ol>
<li>Transformation by homogeneous coordinates：Add another column and let the column assignment $（0,0,…,0,1）$</li>
<li>Invers Transform $M^-1$, it map to the inverse matrix</li>
</ol>
</li>
</ol>
</li>
<li><p>Composing Transforms</p>
<ol start="0">
<li><p>Suppose we want to rotate and translate the picture, we can get the 2 ways: The first is translation then rotation, the other is rotation then translation. <strong>But</strong> compare the two picture, we get the difference picture. So we should know that the transformation sequence/ordering is <strong>matters</strong>.</p>
<p>Associate the matrix multiple and we can easily understand it. But note that martices are applied <strong>right to left</strong>.</p>
</li>
<li><p>We can pre-multiply $n$ matrixs to obtain a single matrix representing combined transform, wich are important for performance （pre-multiply is faster）.</p>
</li>
</ol>
</li>
<li><p>Decomposing Complex Transforms</p>
</li>
<li><p>3D Transformation</p>
<ol start="0">
<li><p>Use homogeneous coordinates: 3D point =$（x,y,z,1）^T$ and 3D vector =$（x,y,z,0）^T$</p>
</li>
<li><p>In general $（x,y,z,w）,w\neq0$ is the 3D point<br>$$<br>(\frac xw,\frac yw,\frac zw)<br>$$</p>
</li>
<li><p>And use $4\times4$ matrices for affine transformations（Other transformation is simliar to this case）<br>$$<br>\cdot \left[ \begin {matrix} x’\\y’\\z’\\1\end{matrix}\right]=<br>\left[ \begin {matrix} a&amp;b&amp;c&amp;t_x\\d&amp;e&amp;f&amp;t_y\\g&amp;h&amp;i&amp;t_z\\0&amp;0&amp;0&amp;1\end{matrix}\right]<br>\cdot \left[ \begin {matrix} x\\y\\z\\1\end{matrix}\right]<br>$$</p>
</li>
<li><p>Be careful this transformation is linear transformation then translation.</p>
</li>
<li><p>Rotate matrices around $x-$, $y-$ or $z-axis$  are<br>$$<br>R_x(\theta)=\left[<br>\begin {matrix}<br>1&amp;0&amp;0&amp;0<br>\\0&amp;cos\theta&amp;-sin\theta&amp;0<br>\\0&amp;sin\theta&amp;cos\theta&amp;0<br>\\0&amp;0&amp;0&amp;1<br>\end{matrix}\right]<br>\\<br>R_y(\theta)=\left[<br>\begin {matrix} cos\theta&amp;0&amp;sin\theta&amp;0<br>\\0&amp;1&amp;0&amp;0<br>\\-sin\theta&amp;0&amp;cos\theta&amp;0<br>\\0&amp;0&amp;0&amp;1<br>\end{matrix}\right]<br>\\<br>R_z(\theta)=\left[<br>\begin {matrix} cos\theta&amp;-sin\theta&amp;0&amp;0<br>\\sin\theta&amp;cos\theta&amp;0&amp;0<br>\\0&amp;0&amp;1&amp;0<br>\\0&amp;0&amp;0&amp;1<br>\end{matrix}\right]<br>$$<br>We can notice a fact that the $R_y（\theta）$ is special, if you want to know more, review the “<em>coss product</em>“ and you will know why this phenomenon will occur. </p>
</li>
<li><p>Euler angles: To compose any 3D rotation from $R_x,R_y,R_z$<br>$$<br>R_{xyz}(\alpha,\beta,\gamma)=R_x（\alpha）R_y（\beta）R_z（\gamma）<br>$$<br>And we often used in flight simulators : roll, pitch, yaw.（中文：偏航、俯仰和滚转）</p>
<p>Althou the Euler angles can’t avoid the Gimbal Lock（ a kind of deadlock ）, and it can’t finish the smooth interpolation of sphere, but it can easily sovle the 3D rotation problem. So we omit it. （If you want to know more, you can google it） .</p>
<ol start="0">
<li><p><strong>Rodrigues’ Rotation Formula</strong>: By angle $\alpha$ round axis $n$, $I$ is <strong>Identity matrix</strong>, and the last matrix we called <strong>dual matrix</strong><br>$$<br>R(\vec n,\alpha)=cos(\alpha)I+(1-cos\alpha)\vec n \vec n^T+sin(\alpha)<br>\left[<br>\begin {matrix} 0&amp;-n_z&amp;n_y<br>\\n_z&amp;0&amp;-n_x<br>\\-n_y&amp;n_x&amp;0<br>\end{matrix}\right]<br>$$</p>
</li>
<li><p>The method of <strong>Quaternions（四元数）</strong>is to solve the interpolation of the rotation. And we omis it in this Blog.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Viewing-Transformaton"><a href="#Viewing-Transformaton" class="headerlink" title="Viewing Transformaton"></a>Viewing Transformaton</h3><ol start="0">
<li><p>View（视图）/ Camera transformation</p>
<ol start="0">
<li><p>What is view transformation — associate the photo when we take.</p>
<p>Generally, when we take a photo, we always do as follows:</p>
<ol start="0">
<li>Find a good place and arrange the elments（Model transformation）</li>
<li>Find a good <em>angle</em> to put the camera（View transformation）</li>
<li>Cheese（Projection transformation）</li>
</ol>
</li>
<li><p>How to perform view transformation?</p>
<ol start="0">
<li><p>Define the camera: mark $\vec e$ as position, $\hat g$ as look-at/gaze direction and $\hat t$ as up direction（assuming perp. to look at）</p>
</li>
<li><p>Key observation: If the camera and all objects move together, the photo will be the same. So we always transform the camera to the origin, up at $Y$, look at the $-Z$, and transform the objects along with the camera.</p>
</li>
<li><p>Transform the camera by $M_{view}$, so it’s located a the origin, up at $Y$, look at $-Z$. In math descibe, we called </p>
<ol start="0">
<li><p>Translates $\vec e$ to origin;</p>
</li>
<li><p>Rotates $\hat g$ to $-Z$;</p>
</li>
<li><p>Rotates $\hat t$ to $Y$;</p>
</li>
<li><p>Rotatse $\hat g \times \hat t$ to $X$</p>
</li>
<li><p>And we write $M_{view}=R_{view}T_{view}$, then translate $\vec e$ to origin<br>$$<br>T_{view}=\left[\begin{matrix}<br>1&amp;0&amp;0&amp;-x_e<br>\\<br>0&amp;1&amp;0&amp;-y_e<br>\\<br>0&amp;0&amp;1&amp;-z_e<br>\\<br>0&amp;0&amp;0&amp;1<br>\end{matrix}\right]<br>$$<br>Then rotate $\hat g$  to $-Z$, $\hat t$ to $Y$, $（g\times t）$ to $X$, we find that it hard to caculate, consider the Orthogonality Matrix, we can find the $R_{view}^{-1}$ is easy to caculate.</p>
<p>Just inverse the rotation $X$ to $（g\times t）$, $Y$ to $\hat t$ and $Z$ to $-\hat g$, then<br>$$<br>R_{view}^{-1}=\left[\begin{matrix}<br>x_{\hat g\times \hat t}&amp;x_t&amp;x_{-g}&amp;0<br>\\<br>y_{\hat g\times \hat t}&amp;y_t&amp;y_{-g}&amp;0<br>\\<br>z_{\hat g\times \hat t}&amp;z_t&amp;z_{-g}&amp;0<br>\\<br>0&amp;0&amp;0&amp;1<br>\end{matrix}\right]<br>$$<br>Because of the property $M^{-1}=M^t$, we can get<br>$$<br>R_{view}=<br>\left[\begin{matrix}<br>x_{\hat g\times \hat t}&amp;y_{\hat g\times \hat t}&amp;z_{\hat g\times \hat t}&amp;0<br>\\<br>x_t&amp;y_t&amp;z_t&amp;0<br>\\<br>x_{-g}&amp;y_{-g}&amp;z_{-g}&amp;0<br>\\<br>0&amp;0&amp;0&amp;1<br>\end{matrix}\right]<br>$$<br>So this is View Transformation Matrix.</p>
</li>
</ol>
</li>
<li><p>Summery </p>
<ol start="0">
<li>Transform objects together with the camera</li>
<li>Until camera’s at the origin, up at $Y$, look at $-Z$</li>
</ol>
</li>
<li><p>Also known as Model/View Transformation</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Projection transformation: 3D to 2D</p>
<p>We can identity orthographic projection and perspective projection by the property: Orthographic projection don’t change parallel lines to intersect, but perspective will.  For example, I know the truth, but why are pigeons so big. </p>
<ol start="0">
<li><p>Orthographic projection</p>
<ol start="0">
<li><p>A simple way of at orgin, looking at $-Z$, up at $Y$ ; <font color="red">Drop $Z$ coordinate</font> and Translate and scale the resultig rectangle to $[-1,1]^2$. （In fact ,the “<em>CGPP</em>“ have the similar descaibe in Chapter 3. But it illustrate the “<em>Durer Image</em>“）;</p>
</li>
<li><p>But in general, we want to map a cubioid $[l,r]\times[b,t]\times[f,n]$ to the “canonical（正则、规范，标准）” cube in $\mathbb R^3$ or $[-1,1]^3$;</p>
</li>
<li><p>Slightly different orders, we center cuboid by translating then scale into “canonical” cube;</p>
</li>
<li><p>And we can get the transformation matrix by （we use right-hand system, if use left-hand system, the forth cow of the second matrix are positive）<br>$$<br>M_{ortho}=<br>\left[\begin{matrix}<br>\frac 2{r-l}&amp;0&amp;0&amp;0<br>\\<br>0&amp;\frac 2{t-b}&amp;0&amp;0<br>\\<br>0&amp;0&amp;\frac 2{n-f}&amp;0<br>\\<br>0&amp;0&amp;0&amp;1<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>1&amp;0&amp;0&amp;-\frac {r+l}2<br>\\<br>0&amp;1&amp;0&amp;-\frac {t+b}2<br>\\<br>0&amp;0&amp;1&amp;-\frac {n+f}2<br>\\<br>0&amp;0&amp;0&amp;1<br>\end{matrix}\right]<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>Perspective（透视） projection</p>
<ol start="0">
<li><p>Some preview</p>
<ol start="0">
<li>It is the most common in CG, art, visual system and etc. </li>
<li>The further objects are smaller</li>
<li>And parallel lines not parallel, it will converge to single point</li>
</ol>
</li>
<li><p>How to do perspective projection </p>
<ol start="0">
<li><p>First “squish” the frustum into a cuboid （$n\rightarrow n,f\rightarrow f$）（$M_{persp\rightarrow ortho}$）（In fact, if you get some Topology knowledge, you will easy to understand it,  just see the  $persp$ </p>
<p>homeomorphic $ortho$）</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/pers_to_ortho.png" alt="pers_to_ortho" style="zoom:50%;">
</li>
<li><p>Do orthographic projection （Because we have known the $M_{ortho}$）</p>
<ol start="0">
<li><p>In order to find a transformation, we should find the relationship betwwn transformed points $（x’,y’,z’）$ and the original points $（x,y,z）$</p>
 <img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/similar.png" alt="similar" style="zoom:50%;">

<p> And acording to the similar triangle we will get<br> $$<br> y’=\frac nz y，x’=\frac nz x<br> $$<br> So in homogeneous coordinatse<br> $$<br> \left(\begin{matrix}x\\y\\z\\1\end{matrix}\right)\rightarrow<br> \left(\begin{matrix}\frac {nx}z\\\frac {ny}z\\unkown\\1\end{matrix}\right)==<br>\left(\begin{matrix} nx\\ ny\\unkown\\z\end{matrix}\right)<br> $$</p>
</li>
<li><p>So the “squish” projection （ persp to ortho） does this<br>$$<br>M_{persp\rightarrow ortho}^{(4\times 4)}\left(\begin{matrix}x\\y\\z\\1\end{matrix}\right)<br>=\left(\begin{matrix} nx\\ ny\\unkown\\z\end{matrix}\right)<br>$$<br>Already good enought to figure out part of $M_{persp \rightarrow ortho}$, and（By using matrices multyple）<br>$$<br>M_{persp \rightarrow ortho}=<br>\left(\begin{matrix}<br>n     &amp;   0  &amp;    0  &amp;  0<br>\\<br>0     &amp;   n  &amp;    0  &amp;  0<br>\\<br>?     &amp;   ?  &amp;    ?  &amp;  ?<br>\\<br>0     &amp;   0  &amp;    1  &amp;  0<br>\end{matrix}\right)<br>$$</p>
</li>
<li><p>Observation: the third row is responsible for $z’$</p>
<ol start="0">
<li><p>Any point on the near plane will not change<br> $$<br> M_{persp\rightarrow ortho}^{(4\times 4)}\left(\begin{matrix}x\\y\\z\\1\end{matrix}\right)<br> =\left(\begin{matrix} nx\\ ny\\unkown\\z\end{matrix}\right)<br> by\space replace \space z \space with \space n\space<br> \left(\begin{matrix}x\\y\\z\\1\end{matrix}\right)\rightarrow<br> \left(\begin{matrix}x\\y\\n\\1\end{matrix}\right)==<br> \left(\begin{matrix} nx\\ ny\\n^2\\n\end{matrix}\right)<br> $$<br> So the third row must be of the form $（0\space 0\space A\space B）$ and<br> $$<br> （0\space 0\space A\space B）<br> \left(\begin{matrix}x\\y\\z\\1\end{matrix}\right)=n^2​<br> $$<br> $n^2$ has nothing to do with $x$ and $y$ . Then we will get the equation $An+B=n^2$</p>
<p> Any point’s $z$ on the far plane will not change: We will know that<br>$$<br>\left(\begin{matrix}0\\0\\f\\1\end{matrix}\right)\rightarrow\left(\begin{matrix}0\\0\\f\\1\end{matrix}\right)==\left(\begin{matrix}0\\0\\f^2\\f\end{matrix}\right)<br>$$</p>
<p>Then we will get the equation $Af+B=f^2$ .</p>
</li>
<li><p>We will get a linear equations, by Cramer method ,we will solve this equations, and the answer are $A=n+f\space ,\space B=-nf$</p>
</li>
<li><p>Finally, every coefficient we will know the matrix $M_{persp\rightarrow ortho}$ </p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>What’s near plane’s $l,r,b,t$ then </p>
<ol start="0">
<li><p>If explicitily specified, good</p>
</li>
<li><p>Sometimes perople prefer: vertical <strong>field-of-view</strong> （fov$Y$）and <strong>aspect ratio</strong>（Assume symmetry）</p>
</li>
<li><p>How to convert from fov$Y$ and aspect $l,r,b,t$？— Trivial</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/fovY.png" alt="fovY"><br>$$<br>tan\frac {fovY}2=\frac t{|n|},aspect=\frac rt<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-Rasterization"><a href="#2-Rasterization" class="headerlink" title="2. Rasterization"></a>2. Rasterization</h2><h3 id="What’s-after-MVP"><a href="#What’s-after-MVP" class="headerlink" title="What’s after MVP?"></a>What’s after <strong>MVP</strong>?</h3><p><strong>M</strong>odel transformation to place objects</p>
<p><strong>V</strong>iew transformation to place camera</p>
<p><strong>P</strong>rojection transformation by Orthograpihc projection（cuboid to “canonical” cube $[-1,1]^3$ ）and Perspective projection （ frustum to “ canonical “ cube）</p>
<ol start="0">
<li><p>we should put Canonical Cube to Screen</p>
<ol start="0">
<li><p>What is a screen?</p>
<ol start="0">
<li><p>An array of pixels</p>
</li>
<li><p>Size of the array: resolution</p>
</li>
<li><p>A typical kind of raster display</p>
</li>
</ol>
</li>
<li><p>Raster == Screen in German</p>
<p>Rasterize == drawing onto the screen</p>
</li>
<li><p>Pixel（FYI, short for “picture element”）</p>
<ol start="0">
<li><p>For now: A pixel is a little square with uniform color</p>
</li>
<li><p>Color is a mixture of （<font color="red">red</font>, <font color="green">green</font>, <font color="blue">blue</font>）</p>
</li>
</ol>
</li>
<li><p>Defining the screen: Slightly different from the text “Tiger book”</p>
<ol start="0">
<li><p>Pixels’ indices are in the form of $（x,y）$ where both $x$ and $y$ are integers</p>
</li>
<li><p>Pixels’ indices are from $（0,0）$ to $（width-1,height-1）$</p>
</li>
<li><p>But for every pixel （x,y）, the center of them are at $（x+0.5,y+0.5）$</p>
</li>
<li><p>The screen covers range $（0,0）$ to $（width,height）$</p>
</li>
<li><p>Irrelevant to $Z$</p>
</li>
<li><p>Transform in $xy$ plane: $[-1,1]^2$ to $[0,width]\times [0,height]$, by using viewport transform<br>$$<br>M_{viewport}=<br>\left(\begin{matrix}<br>\frac {width}2     &amp;   0  &amp;    0  &amp;\frac  {width}2<br>\\<br>0     &amp;   \frac {height}2  &amp;    0  &amp;  \frac{height}2<br>\\<br>0    &amp;   0  &amp;   1  &amp;  0<br>\\<br>0     &amp;   0  &amp;    0  &amp;  1<br>\end{matrix}\right)<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Rasterizing-Triangles-into-Pixels"><a href="#Rasterizing-Triangles-into-Pixels" class="headerlink" title="Rasterizing Triangles into Pixels"></a>Rasterizing Triangles into Pixels</h3><ol start="0">
<li><p>Some Drawing Machine and Different Raster Displays</p>
<ol start="0">
<li><p>CNC sharpie Drawing Machine</p>
</li>
<li><p>Oscilloscope（示波器）</p>
<ol start="0">
<li>The principle: Cathode Ray Tube（阴极射线管）</li>
<li>Televison: Raster Scan to get the image</li>
<li>And it have some treat: Raster Scan Pattern of Interlaced Display（隔行扫描）</li>
</ol>
</li>
<li><p>Frame Buffer: Memory for a Raster Display</p>
</li>
<li><p>Flat Panel Displays</p>
<ol start="0">
<li><p>LCD（Liquid Crystal Display） Pixel</p>
<p>Principle : </p>
<ol start="0">
<li>block or transmit light by twisting polarization </li>
<li>Illumination from backlight</li>
<li>Intermediate intensity levels by partial twist</li>
</ol>
</li>
<li><p>LED（Light emitting diode）</p>
</li>
<li><p>Electrophoretic（Electronic ink）Display</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Rasterization: Drawing to Raster Displays</p>
<p><strong>Triangles - Fundamental Shape Primitives.</strong></p>
<ol start="0">
<li><p>Why Triangles? </p>
<ol start="0">
<li>Most basic polygon —— Break up other polygons</li>
<li>Unique properties —— Guaranteed to be plannar, well-defined interior and well-defined method for interpolation values at vertices over triangle （Barycentric interpolation）</li>
</ol>
</li>
<li><p>What Pixel Values Approximate a Triangle?</p>
<p>Input position of triangle vertices projected on screen, how to outpoot?</p>
<ol start="0">
<li><p>Sampling a Function: Evaluating a function at a point is sampling. We can discretize a function by sampling</p>
<pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">for</span> （<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>xmax<span class="token punctuation">;</span>x<span class="token operator">++</span>） 
     output<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span> f（x）<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
<li><p>Samplng is a core idea in graphics: We sample time（1D）, area（2D）, direction（2D）,volume（3D）and etc.</p>
<ol start="2">
<li><p>Sample if Each Pixel Center is Inside Triangle - Define binary function </p>
<pre class="line-numbers language-c"><code class="language-c">bool inside（tri t<span class="token punctuation">,</span> Point p）<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//struct Point {</span>
<span class="token comment" spellcheck="true">//    Elementtype x, y;</span>
<span class="token comment" spellcheck="true">//};</span>
<span class="token comment" spellcheck="true">//x,y not necessarily integers</span>
<span class="token comment" spellcheck="true">//if Point p（x,y） in the t,return true</span>
<span class="token comment" spellcheck="true">//else return false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Rasterization = Sampling A 2D Indicator Function（The main code as follow）</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span> （<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax<span class="token punctuation">;</span> <span class="token operator">++</span>x）
    <span class="token keyword">for</span>（<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y<span class="token operator">&lt;</span> ymax<span class="token punctuation">;</span> <span class="token operator">++</span>y）
        image<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>inside（tri<span class="token punctuation">,</span>
                           x <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">,</span>
                           y <span class="token operator">+</span> <span class="token number">0.5</span>）<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Another way to judge a point whether in the triangle: Use <strong>Cross Product</strong>:</p>
<p>Suppose $3$ points $A,B,C$,  the point $Q$ we want to judge</p>
<p>We can get $3$ vectors $\vec {AQ},\vec {BQ},\vec {CQ}$</p>
<p>If all the $\vec {AB}\times \vec {AQ},\vec {CA} \times \vec {CQ},\vec {BC}\times \vec {BQ}$  are positive or negative, the point in the triangle.</p>
<p>Else not in the triangle.</p>
</li>
<li><p>Edge Cases : We omit it. But if you want to make some special check, you should treatment it special.</p>
</li>
<li><p>We can take some method to decrease some calculate like bounding box and etc. </p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Rasterization on Real Displays</p>
<ol start="0">
<li><p>Example: Real LCD Screen Pixels （Closeup）（The second called Bayer Pattern）</p>
</li>
<li><p>Real_LCD</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Real_LCD(closeup).png" style="zoom:50%;">

<p>We can see that the <font color="green">green</font> part more than <font color="red">red</font> and <font color="blue">blue</font>, because of  the more sensitive to green for our eyes.</p>
</li>
<li><p>Other Display Methods</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/other_method.png" alt="other_method" style="zoom:50%;">
</li>
</ol>
</li>
<li><p>Assume Display Pixels Emit Square of Light</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/LCD_pixel.png" alt="LCD_pixel" style="zoom:50%;">



</li>
</ol>
<h3 id="Antialiasing"><a href="#Antialiasing" class="headerlink" title="Antialiasing"></a>Antialiasing</h3><ol start="0">
<li><p>Sampling theory</p>
<p>   <strong>Sampling is Ubiquitous in CG</strong></p>
<ol start="0">
<li><p>Rasterization = Sample 2D Positions</p>
</li>
<li><p>Photograph = Sample Image Sensor Plane</p>
</li>
<li><p>Video = Sample Time</p>
</li>
</ol>
<p>   <strong>Sampling <font color="red">Artifacts</font>（Erros / Mistakes / Inaccuracies ） in CG</strong></p>
<ol start="0">
<li><p>Jaggies （Stair case Pattern）</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Jaggies.png" alt="Jaggies" style="zoom:50%;">
</li>
<li><p>Moire Patterns in Imaging</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Moire_Patterns.png" alt="Moire_Patterns" style="zoom:50%;">
</li>
<li><p>Wagon Wheel Illusion （False Motion）</p>
</li>
<li><p>And Many More</p>
<p>Behind the Aliasing Artifacts: </p>
</li>
</ol>
<p>   <strong>Signals are <font color="blue">changing too fast</font> （ high frequency ）but <font color="red"> sampled too slowly</font>.</strong></p>
</li>
<li><p>Antialiasing Idea: Blurring （Pre - Filtering） Before Sampling</p>
<ol start="0">
<li>Rasterization: Point Sampling in Space</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/tri_sample.png" alt="tri_sample" style="zoom:67%;">

<p>This is <strong>Regular Samping</strong>, Note jaggies in rasterized triangle where pixel value are <strong>pure red or white</strong></p>
<ol>
<li><p>Pre-Filter</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/pre_filter_tri_sample.png" alt="pre_filter_tri_sample" style="zoom:67%;">

<p>This is *<em>Antialiased Sampling *</em>. Note antialiased edges in rasterized triangle wher pixel values take intermediate values.</p>
</li>
<li><p>But we can’t sample then filter will lead to “<em>Blurred Aliasing</em>“</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/sample_then_filter.png" alt="sample_then_filter" style="zoom:50%;">

<p>The first is sample then filter, the second is right.</p>
<ol start="0">
<li><p>Why undersampling introduces aliasing and why pre-filtering then sampling can do antialiasing?</p>
<ol start="0">
<li><p>Frequency Domain</p>
<ol start="0">
<li><p>$sin\omega x$ and $cos\omega x$： well-know periodic functions, the periodic, $f$ is frequency.<br>$$<br>f=\frac \omega {2\pi}<br>$$</p>
</li>
<li><p>Fourier Series Expansion: For every periodic functions, it can be written as a linear combination of sine and cosine.</p>
</li>
<li><p>Fourier Transform: spatial domain function $f（x）$ can be transform by Fourier transform $F（\omega）=\int_{-\infty}^{\infty}f（x）e^{-2\pi i\omega x}dx$ to frequency domain $F（\omega）$, and according to Euler Formular $e^{ix}=cosx+isinx$.</p>
</li>
<li><p>Inverse transform: From $F（\omega）$ by  $f（x）=\int_{-\infty}^{\infty}F（\omega）e^{2\pi i \omega x}d\omega$ to $f（x）$</p>
</li>
</ol>
</li>
<li><p>Sampling emulation: Higher Frequencies Need Faster Sampling </p>
<p>Undersampling Creates Frequency Aliases: High-frequency signal is insufficiently sampled: samples erroneously appear to be from a low-frequency signal.</p>
<p>Two frequencies that are indistinguishable at a given sampling  $f$ are called “aliases”（混叠）</p>
</li>
<li><p>Filtering = Getting rid of certain frequency contents</p>
<ol start="0">
<li><p>Example: Visualizing Image Frequency Content</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Fourio_Trans.png" alt="Fourio_Trans"></p>
<p>We can know that the lowest frequency information are gathered in the center of the image, and the brighter the color, the more information there is. So this image has many low frequency information. The frequency around are the detail of the image.（Many natural picture like this.）</p>
</li>
<li><p>Filter out Low Frequencies Only（Edges）</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/filt_low_f.png" alt="filt_low_f"></p>
</li>
<li><p>Filter Out High Frequencies（Blur）</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/filt_high_f.png" alt="filt_high_f"></p>
</li>
<li><p>Filter Out Low and High Frequencies</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/filt_high_and_low.png" alt="filt_high_and_low"></p>
</li>
</ol>
</li>
<li><p>Filtering = Convolution = Average</p>
<p>In a word, convolution can see it as <strong>the “<em>average</em>“ in frequency domain</strong> and the average can see it as <strong>the average in spatial domain</strong></p>
<ol start="0">
<li><p>Convolution</p>
<p>Given a signal sequence $S=[1,3,5,3,7,1,3,8,6,4$ , and a filter $F=[\frac 14,\frac 12,\frac 14]$, the result of the convolution about signal and filter can get a sequence $R$. The $i-th$ element in the result sequence can be caculate by<br>$$<br>R[i]=S[i-1]\times F[1]+S[i]\times F[2]+S[i+1]\times F[3]<br>$$<br>The procesion of it is convolution.</p>
</li>
<li><p>Convolution Theorem: Convolution in the spatial domain is equal to mulitiplication in the frequency domain , and vice versa</p>
<ol start="0">
<li><p>Filter by convolution in the spatial domain</p>
</li>
<li><p>Thansform to frequency domain（Fourier tansform）, multiply by Fourier transform of convolution kernel and Transform back to spatial domain（Inverse Fourier）</p>
</li>
<li><p>Example: </p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/convolution.png" alt="convolution"></p>
</li>
<li><p>Box Filter = “Low Pass Filter”<br>$$<br>\frac 19 \left[ \begin{matrix}1&amp;1&amp;1\\1&amp;1&amp;1\\1&amp;1&amp;1\end{matrix}\right]<br>$$</p>
</li>
<li><p>Wider Filter Kernel = Lower Frequencies</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Sampling = Repeating Frequency Contents</p>
</li>
<li><p>Aliasing = Mixed Frequency Contents</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/alias.png" alt="alias" style="zoom:67%;">
</li>
</ol>
</li>
</ol>
</li>
<li><p>Reduce Aliasing Error</p>
<ol start="0">
<li><p>Increase sampling rate</p>
<ol start="0">
<li><p>Essentially increasing the distance Essentially increasing the distance between replicas in the Fourier domain</p>
</li>
<li><p>Higher resolution displays, sensors, framebuffers…</p>
</li>
<li><p>But: costly &amp; may need very high resolution</p>
</li>
</ol>
</li>
<li><p>Antialiasing: making Fourier contents “narrower” brfore repeating</p>
<ol start="0">
<li><p>Antialiasing = Limiting then repeating </p>
</li>
<li><p>Antialiasing By Averaging Values in Pixel Area</p>
<p>Solution: <font color="red">Convolve</font> $f（x,y）$ by a $1$-pixel box-blur, <font color="red">Then sample</font> at every pixel’s center</p>
</li>
<li><p>Example: Antialiasing by Computing Average Pixel Value</p>
<p>In rasterizing one triangle, the average value inside a pixel area of $f（x,y）= $inside（triangle,point） is equal to the area of the pixel covered by the triangle.</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/an_triangle.png" alt="an_triangle"></p>
</li>
</ol>
</li>
<li><p>Antialiasing By Supersampling （MSAA）</p>
<ol start="0">
<li><p>Supersampling</p>
<p>Approximate the effect of the 1-pixel box filter by sampling multiple locations within a pixel and averaging their values</p>
</li>
<li><p>Example</p>
<ol start="0">
<li><p>Beginning</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/begin.png" alt="begin" style="zoom:33%;">
</li>
<li><p>First Step: Take $N\times N$ samples in each pixel</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/first.png" alt="first" style="zoom:50%;">
</li>
<li><p>Second Step: Average the $N\times N$ samples “inside” each pixel</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/second.png" alt="second" style="zoom:50%;">
</li>
<li><p>then</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/last.png" alt="last" style="zoom:50%;">
</li>
<li><p>Result: This is the corresponding signal emitted by the display, but MSAA doesn’t increase the dpi</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Result.png" alt="Result" style="zoom:50%;">
</li>
</ol>
</li>
<li><p>No free lunch!</p>
<p>What’s the cost of MSAA? More calculate and more buffer.</p>
</li>
<li><p>Milestones</p>
<ol start="0">
<li><p>FXAA（Fast Approximate AA）（快速近似反走样）</p>
<p>No relationship with add more sample, it is the post-processing of the image. It changes the edge with jaggies to non-jaggy edge . It is quickly.</p>
</li>
<li><p>TAA（Temporal AA） /tem’pərəl/ </p>
<p>To get the post frame information and change some of this frame’s value.</p>
</li>
</ol>
</li>
<li><p>Super resolution（超分辨率） / super sampling </p>
<ol start="0">
<li>From low resolution to high resolution</li>
<li>Essentially still “not enough samples” problem</li>
<li>DLSS（Deep Learning Super Sampling）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Visibility-occlusion-Z-Buffer"><a href="#Visibility-occlusion-Z-Buffer" class="headerlink" title="Visibility / occlusion - Z-Buffer"></a>Visibility / occlusion - Z-Buffer</h3><ol start="0">
<li><p>Painter’s Algorithm - Inspired by how painters paint.</p>
<p>Paint from back to front, <font color="red">overwrite</font> in the framebuffer. It requires sorting in depth （$O(nlogn)$） for n triangles. But it can have unresolvable depth order, for example</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/paiting_exception.png" alt="paiting_exception" style="zoom:67%;">



</li>
</ol>
<ol>
<li><p>Z-Buffer- This is the algorithm that eventually won,</p>
<ol start="0">
<li><p>Idea:</p>
<ol start="0">
<li>Store current min.z-value <font color="red">for each sample（pixel）</font></li>
<li>Needs an additional buffer for depth values<ol start="0">
<li>Frame buffer stores color values</li>
<li>Depth buffer（z-buffer）stores depth</li>
</ol>
</li>
</ol>
</li>
<li><p>IMPORTANT: </p>
<p>For simplicity we suppose, <font color="red">z is always positive</font>（smaller z$\rightarrow$closer, larger z$\rightarrow$further）</p>
</li>
<li><p>Example</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/z_buffer_eg.png" alt="z_buffer_eg" style="zoom:67%;">
</li>
<li><p>Pseudocode</p>
<p>Initialize depth buffer to $\infty$, and during rasterization</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>each triangle T<span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>each <span class="token function">sample</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> in T<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>z <span class="token operator">&lt;</span> zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// closest sample so far</span>
            framebuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> rgb<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// update color</span>
            zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// update depth</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">// do nothing, this sample is occluded</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Complexity</p>
<ol start="0">
<li>$O(n)$ for $n$ triangles (assuming constant coverage).</li>
<li>“Sort” $n$ triangles in linear times, because we just find the minimum value, </li>
</ol>
</li>
<li><p>Triangles in different orders, it will have same appearance.</p>
</li>
<li><p>Most important visibility algorithm - Implemented in hardware for all GPUs</p>
</li>
</ol>
</li>
</ol>
<h2 id="3-Shading"><a href="#3-Shading" class="headerlink" title="3. Shading"></a>3. Shading</h2><p>The <strong>definition</strong> of the shading in Merriam-Webster Dictionary is that <strong>the darkening or coloring of an illustration or diagram with parallel lines or a block of color</strong>. </p>
<p>In this course, the process of <font color="red">applying a meterial</font> to an object is shading </p>
<h3 id="A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model"><a href="#A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model" class="headerlink" title="A Simple Shading Model - Blinn-Phong Reflectance Model"></a>A Simple Shading Model - Blinn-Phong Reflectance Model</h3><ol start="0">
<li><p>Perceptual Observation</p>
</li>
<li><p>Shading in Local: </p>
<p>Compute light reflected toward camera at a specific <font color="red">shading point</font></p>
<ol start="0">
<li><p>Inputs:</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/shang_poit_im.png" alt="shang_poit_im" style="zoom: 67%;">

<ol start="0">
<li>Viewer direction $\vec v$</li>
<li>Surface normal $\vec n$</li>
<li>Light directions $\vec L_i$</li>
<li>Surface parameters such as color, shininess and etc</li>
</ol>
</li>
<li><p><font color="red">No shadows</font> will be generated!（ <strong>shading  $\neq$ shadow</strong> ）</p>
</li>
<li><p>Diffuse Reflection（Blinn-Phong）</p>
<ol start="0">
<li><p>Light is scattered uniformly in all directions - Surface color is the same for all viewing directions</p>
</li>
<li><p>Lambert’s cosine law</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Lamberts_cosine_law.png" alt="Lamberts_cosine_law" style="zoom: 50%;">
</li>
<li><p>Light Falloff</p>
<p>Assume there is a loop with $r=1$,  the light source in the center, then the intensity here is $I$.</p>
<p>If when suppose the distance of the center and a point is $r$, then the intensity here is<br>$$<br>\frac I{r^2}<br>$$</p>
</li>
<li><p>Lambertian（Diffuse）Shading</p>
<p>Shading independent of view direction, we will have<br>$$<br>L_d=k_d\frac I{r^2} max(0,\vec n \cdot \vec l)<br>$$<br>where </p>
<p>​    $L_d$ is diffusely reflected light</p>
<p>​    $k_d$ is diffuse coefficient（color）</p>
<p>​    $max(0,\vec n \cdot \vec l)$ is energy received by the shading point, 0 can avoid the negative value</p>
</li>
</ol>
</li>
<li><p>Specular Term（Blinn-Phong）</p>
<ol start="0">
<li><p>Intensity <font color="red">depends</font> on view direction - Bright near mirror reflection direction</p>
</li>
<li><p>$V$ close to mirror direction == <font color="red"><strong>half vector</strong> near normal</font></p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/sular_term.png" alt="sular_term" style="zoom:50%;">

<p>Measure “near” by dot product of unit vectors, and we get this vector<br>$$<br>\vec h = bisector(\vec v, \vec l)=\frac{\vec v + \vec l}{||\vec v + \vec l||}\\<br>L_s=k_s\frac I{r^2}max(0,\vec n \cdot\vec h)^p<br>$$<br>Where </p>
<p>​    $L_s$ is secularly reflected light</p>
<p>​    $k_s$ is specular coefficient</p>
<p>Be care for that $max(0,\vec n \cdot\vec h)^p$ have pow $p$, because the cosine function have a property that increasing p narrows the refection lobe.</p>
</li>
</ol>
</li>
<li><p>Ambient Term</p>
<p>Shading that does not depend on anything</p>
<ol start="0">
<li><p>Add constant color to account for disregarded illumination and fill in black shadows</p>
</li>
<li><p>This is approximate / fake<br>$$<br>L_a=k_aI_a<br>$$<br>Where </p>
<p>​    $L_a$ is reflected ambient light </p>
<p>​    $k_a$ is ambient coefficient</p>
</li>
</ol>
</li>
<li><p>Blinn-Phong Reflection Model</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5CB_P_M.png" alt="B_P_M"><br>$$<br>L=L_a+L_d+L_s<br>=k_aI_a+L_d=k_d\frac I{r^2} max(0,\vec n \cdot \vec l)+k_s\frac I{r^2}max(0,\vec n \cdot\vec h)^p<br>$$</p>
</li>
</ol>
</li>
</ol>
<h3 id="Shading-Frequencies"><a href="#Shading-Frequencies" class="headerlink" title="Shading Frequencies"></a>Shading Frequencies</h3><ol start="0">
<li><p>Shade each triangle（<strong>Flat</strong> shading）</p>
<ol start="0">
<li>Triangle face is flat - one normal vector</li>
<li>Not good for smooth surfaces</li>
</ol>
</li>
<li><p>Shade each vertex（<strong>Gouraud</strong> shading）</p>
<ol start="0">
<li><font color="red">Interpolate</font> colors from vertices across triangle</li>
<li>Each vertex has a normal vector</li>
</ol>
</li>
<li><p>Shade each pixel（Phong shading）</p>
<ol start="0">
<li>Interpolate normal vectors across each triangle</li>
<li>Compute full shading model at each pixel </li>
<li><font color="red">Not the <strong>Blinn-Phong Reflectance Model</strong></font></li>
</ol>
</li>
<li><p>Defining Per-Vertex Normal Vectors</p>
<ol start="0">
<li><p>Best to get vertex normals from the underlying geometry.</p>
</li>
<li><p>Otherwise have to infer vertex normals from triangle faces, such like<br>$$<br>N_v=\frac {\sum _iN_i}{||\sum_iN_i||}<br>$$</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\vertex_normal.png" alt="vertex_normal" style="zoom:50%;">
</li>
<li><p><font color="red">Barycentric interpolation</font> of vertex normals</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\BC_VP.png" alt="BC_VP" style="zoom:50%;">
</li>
<li><p>Don’t forget to <font color="red">normalize</font> the interpolated directions</p>
</li>
</ol>
</li>
</ol>
<h3 id="Barycentric-Coordinates-Interpolation-Across-Triangles"><a href="#Barycentric-Coordinates-Interpolation-Across-Triangles" class="headerlink" title="Barycentric Coordinates - Interpolation Across Triangles"></a>Barycentric Coordinates - Interpolation Across Triangles</h3><ol start="0">
<li><p>Some Problems</p>
<ol start="0">
<li><p>Why do we want to inerpolate</p>
<p>Specify values <strong>at vertices</strong> and Obtain smoothly varying values <strong>across triangles</strong></p>
</li>
<li><p>Wahat do we want to interpolate</p>
<p>Texture coordinates, colors, normal vectors. …</p>
</li>
<li><p>How do we interpolation</p>
</li>
</ol>
</li>
<li><p>Barycentric Coordinates</p>
<p>A coordinate system for triangles $(\alpha, \beta,\gamma)$. For any triangle $ABC$ , assume there is a point $p(x,y)$, then we will get this equation（<font color="red"><strong>Inside the triangle if all three condinates are non-negative</strong></font>）<br>$$<br>(x,y)=\alpha A+\beta B+ \gamma C\\<br>\alpha +\beta +\gamma = 1<br>$$<br>And in the formula, we can get follows accoding to the picture</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/B_C_T_T.png" alt="B_C_T_T" style="zoom: 33%;">

<p>Then<br>$$<br>\alpha =\frac {A_A}{A_A+A_B+A_C}<br>\\<br>\beta =\frac {A_B}{A_A+A_B+A_C}<br>\\<br>\gamma=\frac {A_C}{A_A+A_B+A_C}<br>$$</p>
</li>
<li><p>Barycentric Coordinates：$\alpha =\beta =\gamma = \frac 13$</p>
</li>
<li><p>Barycentric Coordinates： Fomulas<br>$$<br>\alpha=\frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)}<br>\\<br>\beta=\frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)}<br>\\<br>\gamma=1-\alpha -\beta<br>$$</p>
</li>
<li><p>Using interpolate values at vertices<br>$$<br>V=\alpha V_A+\beta V_B+\gamma V_C<br>$$<br>where $V_A,V_B,V_C$ can be positions, texture coordinates, color, normal, depth, material attributes…</p>
<p>But <strong>barycentric coordinates are not invariant under projection!</strong></p>
</li>
</ol>
<h3 id="Graphics-（Real-time-Rendering）Pipeline"><a href="#Graphics-（Real-time-Rendering）Pipeline" class="headerlink" title="Graphics （Real-time Rendering）Pipeline"></a>Graphics （Real-time Rendering）Pipeline</h3><p>A picture can conclude it briefly。</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5Cpipeline_CG.png" alt="pipeline_CG"></p>
<p>Shader Programs</p>
<ol start="0">
<li><p>Program vertex and fragment processing stages</p>
</li>
<li><p>Describe operation on a single vertex（or fragment）</p>
</li>
<li><p>Example GLSL fragment shader program</p>
<pre class="line-numbers language-c"><code class="language-c">uniform sampler2D myTexture<span class="token punctuation">;</span>
uniform vec3 lightDir<span class="token punctuation">;</span>
varying vec2 uv<span class="token punctuation">;</span>
varying vec3 norm<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">diffuseShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vec3 kd<span class="token punctuation">;</span>
    kd <span class="token operator">=</span> <span class="token function">texture2d</span><span class="token punctuation">(</span>myTexture<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    kd <span class="token operator">*</span><span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> norm<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    gl_FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>kd<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Some tips</p>
<ol start="0">
<li>Shader function executes once per fragment</li>
<li>Output color of surface at the current fragements screen sample position</li>
<li>This shader perform a texture lookup to abtain the surface’s material color at this point, then performs a diffuse lighting calculation</li>
</ol>
</li>
</ol>
<h3 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h3><ol start="0">
<li><p>Surfaces are 2D</p>
<p>Surface lives in 3D world space, but every 3D surface point also has a place where it goes in the 2D image（<strong>Texture</strong>）</p>
</li>
<li><p>Visualization of Texture Coordinates</p>
<p>Each triangle vertex is assigned a texture coordinate $（u,v）,u,v\in [0,1]$</p>
</li>
<li><p>Apllying Textures</p>
<ol start="0">
<li><p>Simple Texture Mapping - Diffuse Color</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span> each raterized screen <span class="token function">sample</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">//Usually a pixel's center</span>
    <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token operator">=</span> evaluate texture coordinate <span class="token function">at</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//using barycentric coordinates</span>
     texcolor <span class="token operator">=</span> texture<span class="token punctuation">.</span><span class="token function">sample</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
     set sample's color to texcolor<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//Usually the diffuse albedo Kd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Texture Magnification</p>
<ol start="0">
<li><p>Easy Case</p>
<p>Generally don’t want this — insufficient texture resolution, a pixel on a texture — a texel（纹理元素), and look at the picture</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/T_M_EG.png" alt="T_M_EG"></p>
</li>
<li><p>Bilinear Interpolation</p>
<p>If we want to sample textture value $f(x,y)$ at a point. and there are some points ${P_{blacki}}$ indicate texture sample locations.</p>
<p>We can take 4 nearest sample locations, with texture valus as labeled ${u_{0i}}$, and fractional offsets $(s,t)$ as $(distance(u_{00},x),distance(u_{00},y))$</p>
<p><strong>Linear interpolation（1D）</strong><br>$$<br>lerp(x,v_0,v_1)=v_0+x(v_1-v_0)<br>$$<br><strong>Two helper lerps</strong><br>$$<br>u_0=lerp(s,u_{00},u_{10})<br>\\<br>u_1=lerp(s,u_{01},u_{11})<br>$$<br><strong>Find vertical lerp, to get result:</strong><br>$$<br>f(x,y)=lep(t,u_0,u_1)<br>$$<br>Bilinear interpolation usually gives pretty good results at reasonable costs.</p>
</li>
<li><p>Hard Case</p>
<p>![hard_case_in _tm](<a href="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/hard_case_in" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/hard_case_in</a> _tm.png)</p>
<ol start="0">
<li><p>Screen Pixel “Foortprint” in Texture</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/F_i_T_sp.png" alt="F_i_T_sp" style="zoom:50%;">
</li>
<li><p>Will supersampling Do Antialiasing? </p>
<p><strong>Yes! But costly</strong></p>
<ol start="0">
<li>When highly minified, many texels in pixel footprint</li>
<li>Signal frequency too large in a pixel</li>
<li>Need even higher sampling frequency</li>
</ol>
</li>
<li><p>So what if we don’t sample?</p>
<p> Just need to <strong>get the average value within a range</strong>！</p>
</li>
</ol>
</li>
<li><p>Mipmap</p>
<ol start="0">
<li><p>Mipmap - Allowing （<font color="red">fast, approx., square</font>）range queries</p>
<p>“Mip” comes from the Latin “Multum in parvo”, meaning a multitude in a small space, for example</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/mipmap.png" alt="mipmap"></p>
<p>and we will get “Mip hierarchy（level = D）”</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Mip_hierarchy.png" alt="Mip_hierarchy"></p>
<p>The buffer we need is about 1.33 times than before.</p>
</li>
<li><p>Computing Mipmap Level D</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/compure_mipmap.png" alt="compure_mipmap"></p>
<p>then </p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/mip_map_step_2.png" alt="mip_map_step_2"></p>
<p>We will get<br>$$<br>D=log_2L\\L=max\left(\sqrt{(\frac {du}{dx})^2+(\frac {dv}{dx})^2}, \sqrt{(\frac {du}{dy})^2+(\frac {dv}{dy})^2}\right)<br>$$<br>and then use square approximate the origin area</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5Capproximate_the_area.png" alt="approximate_the_area"></p>
</li>
<li><p><strong>Trilinear Interpolation = Bilinear result（in the same level）+Bilinear result（In the adjacent level）</strong></p>
</li>
<li><p>Mipmap Limitations - Overblur </p>
<p>Anisotropic Filtering: Ripmaps and summed area tables</p>
<ol start="0">
<li>Can look up axis-aligned rectangulare zones</li>
<li>Diagonal footprintfs still a problem</li>
</ol>
<p>EWA filtering</p>
<ol start="0">
<li>Use multiple lookups</li>
<li>Weighted average</li>
<li>Mipmap hierarchy still helps</li>
<li>Can handle irregular footprints</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Applications-of-textures"><a href="#Applications-of-textures" class="headerlink" title="Applications of textures"></a>Applications of textures</h3><p>In modern GPUs, texture = memory + range query（Filtering）. And General method to bring data to fragment calculations.</p>
<p>So it have many usages</p>
<ol start="0">
<li><p>Environment lighting: Spherical Map then Cube Map</p>
</li>
<li><p>Store microgeometry: <strong>Fake</strong> the detailed gemoetry by bump / normal mapping</p>
<ol start="0">
<li><p>Bump Mapping: Adding surface detail without adding more triangles</p>
<p>Note that this is in <strong>local coordinate!</strong> </p>
<ol start="0">
<li><p>Perturb surface normal per pixel（For shading computations only）</p>
<p>Original surface normal $n(p)=(0,1)$</p>
<p>Derivative at $p$ is $dp=c\times [ h(p+1)-h(p)]$</p>
<p>Pertubed normal is then $n(p)=(-dp,1).normalized()$</p>
</li>
<li><p>In 3D</p>
<p>Original surface normal $n(p)=(0,0,1)$</p>
<p>Derivative at $p$ are $\frac {dp}{du}=c_1\times [ h(u+1)-h(u)]$; $\frac {dp}{dv}=c_1\times [ h(v+1)-h(v)]$</p>
<p>Pertubed normal is then $n(p)=(-\frac {dp}{du},-\frac {dp}{dv},1).normalized()$</p>
</li>
<li><p>“Height shift” per texel defined by a texture</p>
</li>
<li><p>Modify normal vector</p>
</li>
</ol>
</li>
<li><p>Displacement mapping - a more advanced approach</p>
<p>Uses the same texture as in bumping mapping</p>
<p>Acturally move the vertices</p>
</li>
</ol>
</li>
<li><p>Procedural textures</p>
</li>
<li><p>Solid modeling</p>
<p>Example: 3D Procedural Nosie + Solid Modeling (Perlin Noise)</p>
</li>
<li><p>Volume rendering </p>
</li>
<li><p>Provide Precomputed Shading</p>
</li>
<li><p>And etc.</p>
</li>
</ol>
<h2 id="4-Geometry"><a href="#4-Geometry" class="headerlink" title="4. Geometry"></a>4. Geometry</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol start="0">
<li><p>Examples of Geometry</p>
</li>
<li><p>Rresent Geometry</p>
<ol start="0">
<li><p>Implicit: Based on lassifying points</p>
<ol start="0">
<li><p>method: </p>
<ol start="0">
<li><p>Algebraic surfaces,</p>
</li>
<li><p>Level sets</p>
<ol start="0">
<li>Closed-form equations are hard to describe complex shapes </li>
<li>Alternative: store a grid of values approximating function</li>
<li>Surface is found where interpolated values equal zero</li>
<li>Provides much more explicit control over shape (like a texture)</li>
</ol>
</li>
<li><p>Distance functions</p>
<p>Giving minimum distance （could be distance） from anywhere to object</p>
</li>
<li><p>Constructive Solid Geometry</p>
<p>Bool operate among some geometry.</p>
</li>
<li><p>Fractals（分形）</p>
</li>
<li><p>and etc</p>
</li>
</ol>
</li>
<li><p>Points satisfy some specified relationshp, example $x^2+y^2+z^2=1$ is a ball. More generally, $f(x,y,z)=0$</p>
</li>
<li><p>Disadvantage is sampling can be hard</p>
</li>
<li><p>Advantage is easy to judge a point inside/outside </p>
</li>
</ol>
</li>
<li><p>Explicit: All points are <strong>given directly</strong> or <strong>via parameter mapping</strong></p>
<ol start="0">
<li><p>method: </p>
<ol start="0">
<li><p>point cloud: Easiest representation: list of points $(x,y,z)$, it can easily represent any kind of geometry. It usually useful for large datasets, often converted into polygon mesh and difficult to draw in undersampled regions.</p>
</li>
<li><p>polygon mesh: Store vertices &amp; polygons （often triangles or quads）. It is easier to do processing / simulation, adaptive sampling, more complicated data structures. Perhaps most common representation in graphic.</p>
<p>The Wavefront Object File (.obj) Format, a commonly used in Graphics research.  Just a text file that specifies vertices, normals, texture coordinates and their connectivities. </p>
</li>
<li><p>subdivision, NURBS </p>
</li>
<li><p>and etc</p>
</li>
</ol>
</li>
<li><p>Example: $f: \mathbb R^2 \rightarrow \mathbb R^3；(u,v)\mapsto (x,y,z) $</p>
</li>
<li><p>Disadvantage is hard to judge a point inside/outside</p>
</li>
<li><p>Advantage is sampling is easy</p>
</li>
</ol>
</li>
<li><p>Each choice best suited to a different task / type of geometry</p>
</li>
<li><p>Best Representation Depends on the Task</p>
</li>
</ol>
</li>
<li><p>Implicit Representations</p>
<ol start="0">
<li>Pro<ol start="0">
<li>compact description （ such like a function）</li>
<li>certain queries easy （inside object, distance to surface）</li>
<li>good for ray-to-surface intersection（more later）</li>
<li>for simple shapes, exact description / no sampling error</li>
<li>easy to handle changes in topology (e.g. fluid)</li>
</ol>
</li>
<li>Cons<ol start="0">
<li>difficult to model complex shapes</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="curves"><a href="#curves" class="headerlink" title="curves"></a>curves</h3><ol start="0">
<li><p>Bezier Curves： Defining Cubic Bezier Curve With Tangents</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Bezier_curv.png" alt="Bezier_curv"></p>
<p>We can easy know that the beginning and ending is $p_0$ and $p_3$.</p>
</li>
<li><p>Evaluating Bezier Curves（de Casteljau Algorithm）</p>
<p>Consider three points（quadratic Bezier）, insert a point using linear interpolation and recursively.</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/B_C_D_C_ALOG.png" alt="B_C_D_C_ALOG" style="zoom:67%;">

<p>and then link the point smoothly and you will get</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5Cb_c_c_d_a_r_a.png" alt="b_c_c_d_a_r_a"></p>
<p>It can be use in more points.</p>
</li>
<li><p>Evaluating Bezier Curves Alegbraic Formula</p>
<ol start="0">
<li><p>de Casteljau algorithm gives a pyramid of coefficients</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\pyirmid_coefficient.png" alt="pyirmid_coefficient" style="zoom:50%;">

<p>then we will get some formulas<br>$$<br>b_0^1(t)=(1-t)b_0+tb_1\\<br>b_1^1(t)=(1-t)b_1+tb_2\\<br>b_0^2(t)=(1-t)b_0^1+tn_1^1<br>=(1-t)^2b_0+2t(1-t)b_1+t^2b_2<br>$$<br>It is Bernstei form of a Bezier cureve of order n:<br>$$<br>b^n(t)=b_0^n(t)=\displaystyle\sum_{j=0}^nb_jB_j^n(t)<br>$$<br>where</p>
<p>​    $b^n(t)$ is bezier curve order $n$（vector polynomial of degree $n$）</p>
<p>​    $b_j$ is Bezier control points（vector in $\mathbb R^n$）</p>
<p>​    $B_j^n(t)$ is Bernsterin polynomial（scalar polynomial of degree $n$）</p>
<p>And Bernstein polynomials<br>$$<br>B_i^n(t)= {n\choose i}t^i(1-t)^{n-i}<br>$$<br>So the Bernstein form of a Bezier curve of order $n$<br>$$<br>b^n(t)=\displaystyle\sum_{j=0}^nb_jB_j^n(t)<br>$$<br>For example, in $\mathbb R^3$ and $n=3$, $b_0=(0,2,3), b_1=(2,3,5), b_2=(6,7,9),b_3=(3,4,5)$</p>
<p>These points define a Bezier curve in 3D that is a cubic polynomial in $t$<br>$$<br>b^n(t)=b_0(1-t)^3+b_13t(1-t)^2+b_23t^2(1-t)+b_3t^3<br>$$</p>
</li>
<li><p>Bernstein Polynomials</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5CBernstein_Poly.png" alt="Bernstein_Poly"></p>
</li>
<li><p>Properties of Bezier Curves</p>
<ol start="0">
<li><p>Interpolates endpoints</p>
<p>$b(0)=b_0,b(1)=b_{end}$</p>
</li>
<li><p>Tangent to end segments</p>
<p>$b’(0)=k(b_1-b_0);b’(1)=k(b_{end}-b_{end-1})$</p>
</li>
<li><p>Affine transformation property</p>
<p>Transform curve by transforming contro points</p>
</li>
<li><p>Convex hull property</p>
<p>Curve is within convex hull of control points</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/convex.png" alt="convex"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Piecewise Bezier Curves</p>
<p>If $n$ is big, it will very hard to control. Instead, chain many low-order Bezier curve.</p>
<p><strong>Piecewise cubic Bezier</strong> the most common technique</p>
<ol start="0">
<li><p>Continuity</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5CTB_CSA.png" alt="TB_CSA"></p>
<p>$C^0$ continuity: $a_n=b_0$</p>
<p>$C^1$ continuity:$a_n=b_0=\frac 12(a_{n-1}+b_1)$</p>
</li>
</ol>
</li>
<li><p>Spline </p>
<p>A continuous curve constructed so as to pass through a given set of points and have a certain number of continuous derivatives. In short, a curve under control </p>
</li>
<li><p>B-splines</p>
<p>Short for basis splines</p>
<p>Require more information than Bezier curves</p>
<p>Satisfy all important properties that Bezier curves have (i.e. superset)</p>
<p>It’s hard to explain, if you want to know more, you can see my article “清华MOOC图形学基础：几何造型”</p>
</li>
</ol>
<h3 id="surfaces"><a href="#surfaces" class="headerlink" title="surfaces"></a>surfaces</h3><ol start="0">
<li><p>Bezier Surfaces</p>
<ol start="0">
<li><p>Bicubic Bezier Surface Patch : Use Bezier Curve in two direction.</p>
</li>
<li><p>Evaluating Bezier Surfaces: </p>
<p>For bicubic Bezier surface patch</p>
<p>​    Input ：$4\times 4$ control points</p>
<p>​    Output：2D surface parameterized by $(u,v)$ in $[0,1]^2$</p>
<p>​    Goal: Evaluate surface position corresponding to $(u,v)$</p>
<p>​    $(u,v)$-separable application of de Casteljau algorithm</p>
<ol start="0">
<li>Use de Casteljau to evaluate point u on each of the 4 Bezier curves in $u$. This gives 4 control points for the “moving” Bezier curve.</li>
<li>Use 1D de Casteljau to evaluate point $v$ on the “moving” curve</li>
</ol>
</li>
</ol>
</li>
<li><p>Mesh Operations：Geometry Processing</p>
<ol start="0">
<li><p>Mesh subdivision - Increase resolution</p>
<p> <img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/subdivision_triansge.png" alt="subdivision_triansge"></p>
<ol start="0">
<li><p>Loop Subdivision（Loop is a person）</p>
<p>Common subdivision rule <font color="red">for triangle meshs</font>.</p>
<p>First, create more triangles（vertices）, second, tune their positions</p>
<p>Split each triangle into four, then assign new vertex positions according to weights（New / old vertices updated differently）</p>
</li>
<li><p>Loop subdivision - Update</p>
<p>For new vertices: we name 2 equilateral triangles’ vertices as $A,B,C$ and $A,B,D$. Then, we find a new vertex in $AB$, and the position should follow $\frac 38\times(A+B)+\frac 18\times (C+D)$</p>
<p>For old vertices: the point in the center of the degree 6 vertices will update to the point which follow the rule ($u$ is the old vertices )$(1-n\times u)\times original_position+u\times neighbor_position_sum$</p>
</li>
<li><p><font color="red">Catmull</font>-Clark Subdivision（<font color="red">General Mesh</font>）</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/MesH_CCSUB.png" alt="MesH_CCSUB" style="zoom:50%;">

<p>Each subdivision step: Add vertex in each face. Add midpoint on each edge and connect all new vertices. </p>
<p>After one subdivision: There have 4 extraordinary vertices, and their degrees are 3（new） or 5（old）and there have no non-quad faces.</p>
<p><strong>FYI</strong>： Catmull-Clark Vertex Update Rules（Quad Mesh）</p>
<p>Face point：<br>$$<br>f=\frac {v_1+v_2+v_3+v_4}4<br>$$<br>Edge point:<br>$$<br>e=\frac {v_1+v_2+f_1+f_2}4<br>$$<br>Vertex point<br>$$<br>e=\frac {f_1+f_2+f_3+f_4+2(m_1+m_2+m_3+m_4)+4p}{16}<br>$$<br>The convergence of Catmull-Clark Subdivition can overall shape and creases.</p>
</li>
</ol>
</li>
<li><p>Mesh simplification - Decrease resolution; try to preserve shape / appearance</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/simlication_tiangle.png" alt="simlication_tiangle"></p>
<ol start="0">
<li>Gold：Reduce number of mesh elements while maintaing the overall shape</li>
<li>Method：Collapsing An Edge - Suppose we simplify a mesh using <font colo="red">edge collapsing</font><ol start="0">
<li>Quadric Error Metrices: New vertex ahould minimize its <font color="red">sum of square distance（L2 distance）</font> to previously related triangle planes.</li>
<li>How ie cost to collapse an edge: computing edge midpoint, measure quadric error</li>
<li>Simplification via Quadric Error：Iteratively collapse edges<ol start="0">
<li>approximate distance to surface as sum of distances to planes containing tricangles.</li>
<li>iteratively collapse edge <font color="red">with smallest score</font></li>
<li>use priority queue and some greedy algorithm</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Mesh regularization - modify sample distribution to improve quality</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5Cmesh_regularization.png" alt="mesh_regularization"></p>
</li>
</ol>
</li>
<li><p>Shadow mapping </p>
<ol start="0">
<li><p>An Image-space Algorithm</p>
<ol start="0">
<li><p>no knowledge of scene’s gfeometry during shadow computation</p>
</li>
<li><p>must deal with aliasing artifacts</p>
</li>
</ol>
</li>
<li><p>Key idea</p>
<p>The points Not in shadow must be seen both <strong>by the light</strong> and <strong>by the camera</strong></p>
</li>
<li><p>Step 1：Render from Light：Depth image from light source</p>
</li>
<li><p>Step 2A：Render from eye：standard image （with depth） from eye </p>
</li>
<li><p>Step 2B：Project to light：Project visible points in eye vie back to light source</p>
<p><font color="red">Note: Reprojected depths from light and eye may not the same, so in some cases, we should BLOCKED it</font></p>
</li>
<li><p>The example you can see the BV1X7411F744?t=1323&amp;p=12 beginning with 60’10’’</p>
</li>
<li><p>Problem with shadow maps</p>
<ol start="0">
<li><p>Hard shadows（points lights only）</p>
<p>Be care for that if the light source have volume, it can be generate soft shadows by other methods, but if it is a point ,it can only generate hard shadows</p>
</li>
<li><p>Quality depends on shadow map resolution（general problm with image-based techniques）</p>
</li>
<li><p>Involves equality comparison of floating point depth values means issues of scale, bias, tolerance</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="5-Ray-Tracing"><a href="#5-Ray-Tracing" class="headerlink" title="5. Ray Tracing"></a>5. Ray Tracing</h2><p>Why Ray Tracing?</p>
<ol start="0">
<li><p>Becase rasterization couldn’t handle global effects well, like（soft） shadows and especially when the light bounces more than once</p>
</li>
<li><p>Rasterization is fast, but quality is relatively low</p>
</li>
<li><p>Ray tracing is accurate, but is <font color="red">very slow</font></p>
<p>Rasterization：<font color="red">real-time</font>, but ray tracing is <font color="blue">offline</font>, and it will use about 10K CPU core hours to render <font color="red">one frame</font> in production.</p>
</li>
</ol>
<p>Light Rays - Three ideas about light rays</p>
<ol start="0">
<li>Light travels in straight lines（though this is wrong）</li>
<li>Light rays do not “collide” with each other if they cross（though this is still wrong）</li>
<li>Light rays travel from the light sources to the eye （but the physics is invariant under path reversal - reciprocity）</li>
</ol>
<p>Ray casting</p>
<ol start="0">
<li>Generate an image by casting one ray per pixel</li>
<li>Check for shadows by sending a ray to the light（《CGPP》chapter3 have some illustrate about it）</li>
</ol>
<h3 id="Whitted-Style（Recursive）-Ray-Tracing"><a href="#Whitted-Style（Recursive）-Ray-Tracing" class="headerlink" title="Whitted-Style（Recursive） Ray Tracing"></a>Whitted-Style（Recursive） Ray Tracing</h3><p>A picture <strong>may</strong> illustrate it clearly</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/whited_ray_tracing.png" alt="whited_ray_tracing"></p>
<ol start="0">
<li><p>Ray-Surface Intersection </p>
<ol start="0">
<li><p>Ray Equatiom </p>
<p> Ray is defined by its origin and a direction vector<br>$$<br>r(t)=O+t\vec d,0\leq t &lt;\infty<br>$$<br>where $r$ is int, along ray, $t$ is “time”, $O$ is origin and $\vec t$ is normalized direction.</p>
</li>
<li><p>Ray Intersection With Sphere</p>
<p>Suppose the equation of sphere is $p:(p-c)^2-R^2=0$， <font color="red">the intersection $p$ must satisfy both equations（ray and sphere）</font></p>
<p>Solve for intersection $(O+t\vec d - c)^2-R^2=0$, by using the quadratic formula ,we can get<br>$$<br>t=\frac {-b\pm \sqrt{b^2-4ac}}{2a}<br>$$</p>
</li>
<li><p>Ray Intersection With Implicit Surface</p>
<p>Firstly, we get a generay implicit surface $p:f(p)=0$</p>
<p>then substitute ray equation: $f(O+t\vec d)=0$</p>
<p>Solve the <strong>real,postive</strong> roots</p>
</li>
<li><p>Ray Intersection With Triangle Mesh（Be careful that the genus should be $0$）</p>
<ol start="0">
<li><p>Why?</p>
<ol start="0">
<li>Rendering: visibility, shadows, lighting …</li>
<li>Geometry: inside/outside test</li>
</ol>
</li>
<li><p>How?</p>
<ol start="0">
<li>Simple idea：just intersect ray with each triangle. But it slow.</li>
<li>Note：Can have 0, 1 intersections（ignoring multiple intersections）</li>
</ol>
<p>Triangle is a plane, Ray-plane intersection. Test if hit point is inside triangle</p>
</li>
<li><p>Plane Equation</p>
<p>Plane is defined by normal vector and a point on plane：a normal, $\vec N$, and a point, $p’$, not in the normal. So the equation is<br>$$<br>p:(p-p’)\cdot \vec N=0 , or \space ax+by+cz+d=0<br>$$</p>
</li>
<li><p>Solve for intersection<br>$$<br>Set\space r=r(t)\\<br>(p-p’)\cdot \vec N=(O+td-p’)\cdot \vec N=0\\<br>t=\frac {(p’-O)\cdot \vec N}{\vec d \cdot \vec N}\space and \space Check:0\leq t\leq \infty<br>$$</p>
</li>
</ol>
</li>
<li><p>Moller Trumbore Algorithm</p>
<p>A faster approach, giving barycentric coordinate directyly.</p>
<p>Derivation in the discussion section!（By cramer）<br>$$<br>\vec O+t\vec D=(1-b_1-b_2)\vec P_0+b_1\vec P_1+b_2\vec P_2\\<br>\left[\begin{matrix} t\\b_1\\b_2 \end{matrix}\right]=\frac 1{\vec S_1 \cdot \vec E_1}\left[\begin{matrix} \vec S_2\cdot \vec E_2\\\vec S_1\cdot \vec S\\\vec S_2\cdot \vec D \end{matrix}\right]<br>$$<br>where<br>$$<br>\vec E_1=\vec P_1 - \vec P_0\\<br>\vec E_2=\vec P_2 - \vec P_0\\<br>\vec S=\vec O -\vec P_0\\<br>\vec S_1=\vec D \times \vec E_2\\<br>\vec S_2=\vec S \times \vec E_1<br>$$</p>
</li>
<li><p>Accelerating Ray-Surface Intersection</p>
<ol start="0">
<li><p>Simple ray-scene intersection</p>
<p>Exhaustively test ray-intersection with every objecy and should find the closet hit（with minimum $t$）. The problem：Naive algorithem =  pixels $\times$ objects（$\times$ bounces） and it  is very slow</p>
</li>
</ol>
</li>
<li><p>Bounding Volume</p>
<p>Quick way to avoid intersections：bound complex object with a simple volume, which object is fully contained in the volum. It can be easy know that the ray doesn’t hit the volume, it doesn’t hit the object. So test BVol first, then test object if it hits</p>
<ol start="0">
<li><p>Ray-Intersection With Box</p>
<p>Understanding：<strong>box is the itersection of 3 pairs of slabs</strong></p>
<p>Specifically：We often use an <strong>Axis-Aligned Bounding Box（AABB）</strong></p>
</li>
<li><p>Ray Intersection with Axis-Aligned Box</p>
<p>2D example; 3D is the same.</p>
<p>We compute intersections with slabs and take intersection of $t_{min}/t_{max}$ intervals</p>
<p>The following picture showed the Intersection with $x$ plane</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/AABB_RA.png" alt="AABB_RA" style="zoom:67%;">

<p>The following picture showed the Intersection with $y$ plane</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/AABB_RAY.png" alt="AABB_RAY" style="zoom:50%;">

<p>The following picture showed the Final Intersection result</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\AABB_RA_FINAL.png" alt="AABB_RA_FINAL" style="zoom:50%;">
</li>
<li><p>Recall：a box（3D）= three pairs of infintely large slabs</p>
<ol start="0">
<li><p>Key ideas：The ray enters the box <font color="blue"><strong>only when</strong></font> it enters all pairs of slabs and exits the box <font color="red"><strong>as long as</strong></font> it exits any pair of slabs.</p>
<p>For each pair, caculate the $t_{min}$ and $t_{max}$（negative is fine）So, for the 3D box, $t_{enter}=max(t_{min}),t_{exit}=min(t_{max})$</p>
</li>
<li><p>If $t_{enter}&lt;t_{exit}$, we know the ray <font color="Orange"> stays a while</font> in the box（So they must intersect！）（not done yet, see the next slide）</p>
</li>
<li><p>However, ray is not a line, it should check whether $t$ is   negative for physical coreectness</p>
</li>
<li><p>What if $t_{exit}&lt;0$? It means that the box is “behind” the ray  - no inersection！</p>
</li>
<li><p>What if $t_{exit}\geq 0$ and $t_{enter}&lt; 0$? It means the rays orgin is inside the box - have intersection</p>
</li>
<li><p>In a nutshell, ray and AABB intersect if and only if<br>$$<br>t_{enter}&lt;t_{exit}\ and \space t_{exit}\geq 0<br>$$</p>
</li>
</ol>
</li>
<li><p>Why Axis-Aligned?</p>
<p>General model, the $t$ we should have 3 subtractions, 6 multiplies and i division; but the slabs perpendicular to x-axis just need 1 subtraction and 1 division（recall the fomula from the foregoing)</p>
</li>
<li><p>Using AABBs to accelerate ray tracing </p>
<ol start="0">
<li><p>Uniform grids</p>
<ol start="0">
<li>Preprocess - Build Acceleration Grid<ol start="0">
<li>Find bounding box</li>
<li>Create grid</li>
<li>Store each object in overlapping cells</li>
<li>Step through grid in ray traversal order - For each grid cell：Test intersection with all objects stored at that cell</li>
</ol>
</li>
<li>Grid Resolution<ol start="0">
<li>One cell - no spped up</li>
<li>Too many cells - Inefficiency due to extraneous grid traversal</li>
<li>Heuristic - cells = $C\times objs$ ,$C\approx 27$ in 3D</li>
</ol>
</li>
<li>When They Work Well on large collection of objects that are distributed evenly in size and space</li>
<li>When they Fail that “Teapot in a stadium”  problem</li>
</ol>
</li>
<li><p>Spatial Partitions - example by KD-Tree</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\spacetial_pation.jpg" alt="spacetial_pation" style="zoom: 67%;">

<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/KD_TREE1.png" alt="KD_TREE1"></p>
<ol start="0">
<li><p>Bilud: Internal nodes store</p>
<ol start="0">
<li>Split axis: $x,y$ or $z$ axis</li>
<li>Split position: coordinate of split plane along axis</li>
<li>childrenL pointers to child nodes</li>
<li><strong>No ovjects are stored in internal nodes</strong></li>
<li>Leaf nodes store list of objects</li>
</ol>
</li>
<li><p>Traversing a KD-Tree</p>
<p>If the ray have intersect with the <strong>leaf</strong> node, the program will check whether the ray intersect with all objects. </p>
</li>
</ol>
</li>
<li><p>Object Partitions - Volume Hierarchy（BVH）</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/BVH_EXAMPLE.png" alt="BVH_EXAMPLE"></p>
<p>Find bounding box, then recursively split set of objects in two subsets. Then <strong>recompute</strong> the bounding box of the subsets.</p>
<p>Stop when necessary and store objects in each leaf node</p>
<ol start="0">
<li><p>Building</p>
<ol start="0">
<li><p>Choose a dimension to split</p>
</li>
<li><p>Heuristic #1： Always choose the longest axis in node</p>
<p>​                 #2：Split node at location of <font color="red">median</font> object（keep balance）</p>
<p>Be careful that in a random sequence, if you want to find the $n-th$ number, it just need $O(n)$</p>
</li>
<li><p>Termination criteria: stop when node contains few elements</p>
</li>
</ol>
</li>
<li><p>BVH Traversal’s’ pseudocode</p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">Intersect(Ray ray, BVH node){
    if (ray misses node.bbox) return;
    if (node is a leaf node)
        test intersection with all objs;
        return closeest intersection;

    hit1 = Intersect(ray, node.childl);
    hit2 = Intersect(ray, node.childr);

    return the closer of hit1, hit2;
} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
<li><p>Spatial vs Object Partions</p>
<ol start="0">
<li>Spatial<ol start="0">
<li>Partition space into non-overlapping regions</li>
<li>An  object can be contained in multiple regions</li>
</ol>
</li>
<li>Object partition<ol start="0">
<li>Partition set of objects into disjoint subsets</li>
<li>Bounding boxes fore each set may overlap in space</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Basic-radiometry"><a href="#Basic-radiometry" class="headerlink" title="Basic radiometry"></a>Basic radiometry</h3><p>Advertisement：new topic from now on, scarcely covered in other graphics courses</p>
<ol start="0">
<li><p>Motivation</p>
<p>In assignment 3, we implement the Blinn-Phong model. The light intensity $I=10$ for example, but what is $10$? But the Whitted style ray tracing doesn’t give you CORRECT results if just “$I=10$”</p>
<p>All the answers can be found in radiometry</p>
</li>
<li><p>Radiometry</p>
<p>Measurement system and units for illumination. And it can accurately measure the spatial properties of light. The radiometry can perform lighting calculations in a physically correct manner</p>
<ol start="0">
<li><p>Radiant flux</p>
<ol start="0">
<li><p>Radiant Energy - the energy of electromagenetic radiation. It is measured in units of joules, and denoted by the symbol：$Q[J=Joule]$</p>
</li>
<li><p>Radiant flux（power） is the ennergy emitted, reflected, trransmitted or received, per unit time<br>$$<br>\Phi \equiv\frac {dQ}{dt}[W=Watt][lm=lumen]<br>$$</p>
</li>
</ol>
</li>
<li><p>Intensity</p>
<ol start="0">
<li><p>The radiant （luminous） intensity is the power per unit <strong>solid angle（立体角）</strong> emitted by a point light source<br>$$<br>I(\omega)\equiv\frac {d\Phi}{d\omega}[\frac W{sr}][\frac {lm}{sr}=cd=candela]<br>$$<br>The candela is one of the seven SI base units</p>
</li>
<li><p>Angles and Solid Angles</p>
<ol start="0">
<li><p>Angles：ratio of subtended arc length on circle to radius $\theta = \frac lr$, circle has $2 \pi$ radians</p>
</li>
<li><p>Solid angle：ratio of subtended area on sphere to radius squared $\Omega=\frac A{r^2}$, sphere has $4\pi$ steradians</p>
</li>
<li><p>Differential Solid Angles：</p>
<p>$dA=(rd\theta)(d\sin\theta d\phi)=r^2\sin\theta d\theta d\phi$</p>
<p>$d\omega=\frac {dA}{r^2}=\sin\theta d\theta d\phi$</p>
<p>$\Omega=\int_{S^2}d\omega=\int_0^{2\pi}\int_0^{\pi}\sin\theta d\theta d\phi=4\pi$</p>
</li>
<li><p>$\omega$ as a direction vector </p>
</li>
<li><p>Isotropic Point Source<br>$$<br>\Phi c= \int_{S^2}Id\omega=4\pi I,then\space I=\frac {\Phi}{4\pi}<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Irradiance</p>
<p>The irradiance is the power per（perpendicular/projected） unit area incident on a surface point<br>$$<br>E(x)\equiv\frac {d\Phi(x)}{dA}[\frac W{m^2}][\frac {lm}{m^2}=lux]<br>$$<br>Review Lambert’s Cosine Law, the irradiance at surface is proportional to cosine of angle between light direction and surface normal</p>
<p><strong>Correction：Irradiance Falloff</strong></p>
<p>Assume light is emitting power $\Phi$ in a uniform angular distributition, Compare irradiance st surface of two shperes:</p>
<ol start="0">
<li>$r=1:E=\frac {\Phi}{4\pi}$</li>
<li>$r=x$：$E’=\frac {\Phi}{4\pi r^2}=\frac E{r^2}$</li>
</ol>
</li>
<li><p>Radiance</p>
<p>Radiance is the fundamental field quantity that describes the distribution of light in an environment</p>
<ol start="0">
<li>Radiance is the quantity associated with a ray</li>
<li>Rendering is all about computin radiance</li>
</ol>
<p>The radiance （luminance）is the power emitted, reflected, transmitted or received by a surfac, <font color="red">per unit solid angle</font>, <font color="blue">per projected unit area</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/radiance.jpg" alt="radiance"><br>$$<br>L(p,\omega)\equiv \frac {d^2\Phi(p,\omega)}{d\omega dA\cos \theta}[\frac W{sr \space m^2}][\frac {cd}{m^2}=\frac{lm}{sr\space m^2}=nit]<br>$$<br>where $\cos \theta$ account for projected surface area</p>
<p>Recall</p>
<ol start="0">
<li>Irradiance ：power per projected unit area</li>
<li>Intensity：power per solid angle</li>
</ol>
<p>So</p>
<ol start="0">
<li>Radiance ：Irradiance per solid angle</li>
<li>Radiance ：Intensity per projected unit area</li>
</ol>
</li>
<li><p>Irradiance vs. Radiance</p>
<p>Irradiance：total power received by area $dA$</p>
<p>Radiance：power ceceived by area $dA$ from “direction” $d\omega$</p>
<p>and we have $H^2$ is a unit Hemisphere<br>$$<br>dE(p,\omega)=L_i(p,\omega)\cos\theta d\omega\\<br>E(p)=\int_{H^2}L_i(p,\omega)\cos \theta d\omega<br>$$</p>
</li>
</ol>
</li>
<li><p>Bidirectional Reflectance Distribution Function（双向反射分布函数：BRDF）</p>
<ol start="0">
<li><p>Reflection at a Point</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\reflection_at_a_point.png" alt="reflection_at_a_point" style="zoom:50%;">

<p>Radiance from direction $\omega_i$ turns into the power $E$ that $dA$ receives, then power $E$ will become the radiance to any other direction $\omega_i$</p>
<p>The differential irradiance incoming is $dE(\omega_i)=L(\omega_i)\cos\theta_id\omega_i$, the differential radiance exiting （due to $dE(\omega_i)$）： $dL_r(\omega_r)$</p>
</li>
<li><p><strong>BRDF’s</strong> Definetion</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/BRDF.png" alt="BRDF"></p>
<p>The Bidirectional Reflectance Distribution Function（BRDF） represents how much light is reflected into each outgoing direction $\omega_r$ from each incoming direction<br>$$<br>f_r(\omega_i \rightarrow \omega_r)=\frac {dL_r(\omega_r)}{dE_i(\omega_i)}=\frac{dL_r(\omega_r)}{L_i(\omega_i)\cos\theta_id\omega_i }[\frac1{sr}]<br>$$<br>Emit the mathematical and physical analysis, the BRDF is illustrate the interact  object with the light,. So it can determine the material of the object.</p>
</li>
<li><p>The Reflection Equation:<br>$$<br>L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i \rightarrow\omega_r)L_i(p,\omega_i)\cos\theta_id\omega_i<br>$$</p>
</li>
<li><p>Recursive Equation</p>
<p>Reflected radiance depends on incoming radiance, but incoming radiance depends on reflected radiance（at another point in the scene）</p>
</li>
<li><p>The Rendering Equation</p>
<p>Re-write the reflection equation<br>$$<br>L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i \rightarrow\omega_r)L_i(p,\omega_i)\cos\theta_id\omega_i<br>$$<br>by adding an Emission term to make it general. So the Rendering Equation is<br>$$<br>L_o(p,\omega_o)=L_e(p,\omega_o)+\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot\omega_i)d\omega_i<br>$$<br>Node that we assume that all directions are pointing <font color="red">outwards</font> now</p>
</li>
<li><p>Reflection Equation</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Reflection_equatrion.png" alt="Reflection_equatrion" style="zoom: 67%;">
$$
L_r(x,\omega_r)=L_e(x,\omega_r)+L_i(x,\omega_i)f(x,\omega_i,\omega_r)(\omega_i.n)
$$
Where $L_r$ is Reflected Light（output image）, $L_e$ is Emiision, $L_i$ is incident light (from light source) , $(\omega_i,n)$ is cosine of incident angel and $f$ is BRDF, then we add some extra light source

<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Reflection_equations.png" alt="Reflection_equations" style="zoom: 67%;">

<p>the Equation now change to<br>$$<br>L_r(x,\omega_r)=L_e(x,\omega_r)+\sum L_i(x,\omega_i)f(x,\omega_i,\omega_r)(\omega_i.n)<br>$$<br>Then change an area to light source area </p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Reflection_equation_area.png" alt="Reflection_equation_area" style="zoom:67%;">

<p>the equation change to<br>$$<br>L_r(x,\omega_r)=L_e(x,\omega_r)+\int_{\Omega} L_i(x,\omega_i)f(x,\omega_i,\omega_r)(\omega_i.n)d\omega_i<br>$$<br>But some of light comes from other object by reflecting, so the pic would change </p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\Comes_from_reflect.png" alt="Comes_from_reflect" style="zoom:67%;">

<p>and the equation becomes to<br>$$<br>L_r(X,\omega_r)=L_e(X,\omega_r)+\int_{\Omega} L_r(X’,-\omega_i)f(x,\omega_i,\omega_r)(\omega_i.n)d\omega_i<br>$$<br>where $L_r$ there is reflected light.</p>
</li>
<li><p>Rendering Equation as Intergral Equation<br>$$<br>L_r(X,\omega_r)=L_e(X,\omega_r)+\int_{\Omega} L_r(X’,-\omega_i)f(x,\omega_i,\omega_r)(\omega_i.n)d\omega_i<br>$$<br>is a Fredholm Intergral Equation of second kind [extensively studied numerically] with canonical form<br>$$<br>L(u)=e (u)+\int L(v)K(u,v)dv<br>$$<br>even we can write it as linear operator equation<br>$$<br>l(u)=e(u)+\int l(v)K(u,v)dv<br>$$<br>where $K(u,v)$ is kernel of equation Light transport operator, and it can be write as<br>$$<br>L=E+KL<br>$$<br>It can be sicretized to a simple matrix equation[or system of simultaneous linear equations]（$L$,$E$ are vectors, $K$ is the light transport matrix）. Then it can general class numberucak Monte Carlo methids and approximate set of all paths of light in scene<br>$$<br>L=E+KL\\IL-KL=E\\(I-K)=E\\L=(I-K)^{-1}E<br>$$<br>According to binomia theorem（二项式定理）<br>$$<br>L=(I+K+K^2+K^3+…)E\\L=E+KE+K^2E+K^3E+…<br>$$<br>then the $E$s of last equation, from the left to right, we can illustrate them ase Emission directly from light sources, direct illumination on surfaces, indirect illumiantion（one bounce indirect[Mirrors, Refraction]） and Twoi bounce indirect illumation and etc.</p>
<p>We can shading in rasterization on $E$ and $KE$, but the follows are hard to shade</p>
</li>
</ol>
</li>
</ol>
<h3 id="Probability-Review"><a href="#Probability-Review" class="headerlink" title="Probability Review"></a>Probability Review</h3><p>Review some <strong>easy</strong> probability knowledge which will use in the following content</p>
<ol start="0">
<li><p>Random Variables</p>
<p>$X$：random variable. Represents a distribution of potential values</p>
<p>$X\sim p(x)$：probability density function（PDF）. Describles relative probability of a random process choosing value $x$</p>
</li>
<li><p>Probabilities</p>
<p>n discrete value $x_i$, With probability $p_i$, Requirements of a probability distribution：$p_i\geq0$, $\sum p_i=1$</p>
</li>
<li><p>Expected Value of a Random Variable</p>
<p>The average value that one obtains if repeatedly drawing samples from the random distribution. $X$drawn from distribution with $n$ discrete values $x_i$ with probabilities $p_i$, the expected value of $X: E(x)=\sum x_ip_i$</p>
</li>
<li><p>Continuous Case：<font color="red"> Probability Distribution Function（PDF)</font></p>
<p>A random variable $X$ that can take any of a continuos set of values. where the relative probability of a particular value is given by a continuous probability density function $p(x)$.</p>
<p>Condition on $p(x)\geq0\ and\ \int p(x)dx=1$</p>
<p>Expected value of $X：E(X)=\int xp(x)dx$</p>
</li>
<li><p>Function of a Random Variable</p>
<p>A function $Y$ of a random variabvle $X$ is also a random variable: $X\sim p(x)$ and $Y=f(X)$, the expected value oif a function of a random variable $E(Y)=E(f(x))=\int f(x)p(x)dx$</p>
</li>
<li><p>Monte Carlo Intergration</p>
<p><strong>Why</strong>：We want to solve an intergral, but it can be too difficult to solve annalyticcally</p>
<p><strong>How</strong>：estimate the integral of a function by averraging random samples of the function’s value</p>
<ol start="0">
<li><p>Some definetion of it</p>
<ol start="0">
<li>Deinite integral： $\int_a^bf(x)dx$</li>
<li>Random variable：$X_i\sim p(x)$</li>
</ol>
<p>Then the Monte Carlo estimator is<br>$$<br>F_N=\frac 1N\displaystyle\sum_{i=1}^N\frac {f(X_i)}{p(X_i)}<br>$$</p>
</li>
<li><p>Example Uniform Monte Carlo Estimator</p>
<p>Assume $f(x)=C$</p>
<ol start="0">
<li><p>Deinite integral： $\int_a^bf(x)dx$</p>
</li>
<li><p>Uniform Random variable：$X_i\sim p(x)=\frac 1{b-a}$</p>
</li>
</ol>
<p>Then the basic Monte Carlo estimator<br>$$<br>F_N=\frac {b-a}N\displaystyle\sum_{i=1}^Nf(X_i)<br>$$</p>
</li>
<li><p>Some notes</p>
<ol start="0">
<li>The more samples, the less variance</li>
<li>Sample on $x$, intergrate on $x$</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h3><ol start="0">
<li><p>Motibation：Whitted-Style Ray Tracing</p>
<ol start="0">
<li><p>Whitted-style ray tracing：</p>
<ol start="0">
<li>Always perform specular reflections / refractions</li>
<li>Stop bouncing at diffuse surfaces</li>
</ol>
<p>But it may not reasonable , so let’s progressively improve upon Whitted-Style Ray Tracing and lead to our path tracing algorithm!</p>
</li>
<li><p>Problem of Whitted-Style Ray Tracing</p>
<ol start="0">
<li>Glossy reflection</li>
<li>Diffuse materials</li>
</ol>
</li>
<li><p>So it seems that Whitted-Style ray tracing is <strong>Wrong</strong>, but the rendering equation is corret</p>
<p>But it involves：Solving an integral over the hemisphere and recursive execution</p>
</li>
</ol>
</li>
<li><p>A Simple Monte Carlo Solution</p>
<p>Suppose we want to render <strong>one pixle（point）</strong>in the followingf scene for <strong>direct illumination</strong> only</p>
<p> <img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/EXAMPLE_IN_PATHTRA.png" alt="EXAMPLE_IN_PATHTRA"></p>
<p>Abuse the concept of Reflection Equation a little bit<br>$$<br>L_o(p,\omega_o)=\int_{\Omega^+}L_i(p_i,\omega_i)f_r(p,\omega_i,\omega_o)( n\cdot \omega_i)d\omega_i<br>$$<br>Note again that we assume all direction are <font color="red">pointing outwards</font>. Fancy as it is , it’s still just an integration over directions. So, of course, we can solve it using Monte Carlo integration.</p>
<p>We want to comput the radiance at $p$ towards the camera<br>$$<br>L_o(p,\omega_o)=\int_{\Omega^+}L_i(p_i,\omega_i)f_r(p,\omega_i,\omega_o)( n\cdot \omega_i)d\omega_i\\<br>\int_a^bf(x)dx\approx\frac 1N\displaystyle\sum_{i=1}^N\frac {f(X_i)}{pdf(X_i)}\ X_k\sim p(x)<br>$$</p>
<p>$$<br>f(x)=L_i(p_i,\omega_i)f_r(p,\omega_i,\omega_o)( n\cdot \omega_i)<br>$$</p>
<p>So, what’s our PDF?</p>
<p>We assume uniformly sampling the hemisphere, the PDF is $p(\omega_i)=\frac 1{2\pi}$</p>
<p>So, in general<br>$$<br>L_o(p,\omega_o)=\int_{\Omega^+}L_i(p_i,\omega_i)f_r(p,\omega_i,\omega_o)( n\cdot \omega_i)d\omega_i<br>\\\approx \frac 1N\displaystyle\sum_{i=1}^N\frac{L_i(p_i,\omega_i)f_r(p,\omega_i,\omega_o)( n\cdot \omega_i)}{pdf(\omega_i)}<br>$$<br>Note abuse notation a little bit for $i$</p>
<p>Then we will write pseudocode</p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">shade(p, wo)
    Randomly choose N direcytions wi~pdf
    L0 = 0.0
    For each wi
        Trace a ray r(p,wi)
        If ray r hit the light
            Lo += ( 1 / N ) * L_i * f_r * cosine / pdf(wi)
    return Lo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Introduction Global Illumination</p>
<ol start="0">
<li><p>One more step forwad - What if a ray hits an object?</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Questyion_in_global.png" alt="Questyion_in_global"></p>
<p>We can know that $Q$ also reflects light to $P$. </p>
<p>How much? The dir.illum. at Q</p>
<p>So the pseudocode can revise</p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">shade(p, wo)
    Randomly choose N direcytions wi~pdf
    L0 = 0.0
    For each wi
        Trace a ray r(p,wi)
        If ray r hit the light
            Lo += ( 1 / N ) * L_i * f_r * cosine / pdf(wi)
        //new here
        Else If ray r hit an object at q
            Lo += ( 1 / N ) * shade(q, -wi) * f_r * cosine / pdf(wi)
    return Lo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>But we doesn’t sovle it. Because</p>
<ol start="0">
<li><p>Explosion of rays as bounces go up：$num_{RAY}=N^{bounces}$</p>
<p>We observation：rays will not explode if and only if $N=1$, So the</p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">shade(p, wo)
    Randomly choose only ONE direcytions wi~pdf
    Trace a ray r(p,wi)
    If ray r hit the light
        return L_i * f_r * cosine / pdf(wi)
    Else If ray r hit an object at q
        return shade(q, -wi) * f_r * cosine / pdf(wi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>This is <font color="red"> path tracing</font>! （FYI, Distributed Ray Tracing if N != $1$）</p>
</li>
<li><p>Ray Generation</p>
<p>Maybe some readers will think that this will be nosiy! But don’t be worry, just trace more paths through each pixel and average their radiance</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/rAY_GENERATION_PATH.png" alt="rAY_GENERATION_PATH"></p>
<p>Then, about this ,it is very similar to ray casting in ray tracing</p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">ray_ generation (camPos, pixel)
    Uniformly choose N sample positions within the pixel
    pixel_ radiance = 0.0
    For each sample in the pixel
        Shoot a ray r(camPos, cam_ to_ sample)
        If ray r hit the scene at p
            pixel_ radiance += 1 / N * shade(P, sample_to cam)
        Return pixel_ radiance    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Path Tracing</p>
<p>But their have some other problems in shade()？The recursive algorithm will never stop!</p>
<p>Dilemma: the light does not strop bouncing indeed</p>
<p>Cutting #bounces == cutting energy</p>
<p>Solution：Russian Roulette（RR）- all about probability</p>
<p>​                   With probability $0&lt;P&lt;1$, you are fine</p>
<p>​                   With probability $1-P$, otherwise</p>
<p>Previously, we always shoot a ray at a shading point and get the shading result $L_o$, suppose we manually set a probability $P(0&lt;P&lt;1)$</p>
<p>With probability $P$, shoot a ray and return the **shading result divided by P：$L_o/P$</p>
<p> With probability $1-P$, don’t shoot a ray and you’ll get <font color="red">0</font> </p>
<p>In this way, you can still <strong>expect</strong> to get $L_o$：$E=P\times(\frac {L_o}{P}+(1-P)\times 0)=L_o$</p>
<p>Now we revise the API</p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">shade(p, wo)
    Manually specify a probability P_RR
    Randomly select ksi in a uniform dist. in[0,1]
    If (ksi>P_RR) return 0.0;

    Randomly choose only ONE direcytions wi~pdf
    Trace a ray r(p,wi)
    If ray r hit the light
        return L_i * f_r * cosine / pdf(wi) / P_RR
    Else If ray r hit an object at q
        return shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Path Tracing</p>
<p>Now we already have a correct version of path tracing, but it’s not really efficient. The lower samples per pixel（SPP） , the  more noisy . Before we make it better, we shoule understand the reason of being inefficient.</p>
<ol start="0">
<li><p>Sampling the Light</p>
<p>Consider the same point, the volume of the light source will change. In one case, only 5 rays can meet the light. But in the specail case that 50,000 rays but only one meet the light. </p>
<p>In the latter, <strong>a lot of rays are “wasted”</strong>, if we uniformly sample the hemisphere at the shading point.</p>
</li>
<li><p>Pure math method</p>
<p>Monte Carlo methods allows any sampling methods, so we can sample the light（therefore no rays are “wasted”）</p>
<p>Assume uniformly sampling on the light, $pdf=\frac 1A$, beacuse $\int pdf dA=1$</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/MthPathtraci.png" alt="MthPathtraci" style="zoom:50%;">

<p>But the rendering equation intergrates on the solid angle:$L_o=\int L_ifr \cos\theta d\omega$</p>
<p>Recall Monte Carlo Intergration：sample on $x$ &amp; integrate on $x$.</p>
<p>We change it to <strong>sapmle on $dA$ and intergral of $A$</strong>, which we just need the relationship between $d\omega$ and $dA$.</p>
<p>Acoording to the picture above, we can easy get that<br>$$<br>d\omega=\frac {dA\cos \theta ’}{||x’-x||^2}<br>$$<br>Note the $\theta ‘$ not the $\theta$, then rewrite the rendering equation as<br>$$<br>L_o(x,\omega)=\int _A L_i(x,\omega_i)f_r(x,\omega_i,\omega_o)\frac {\cos \theta\cos \theta ’}{||x’-x||^2}dA<br>$$<br>Now an intergration on the light ! Monte Carlo intergration：$f(x)$ everything inside $pdf :\frac 1A$</p>
</li>
<li><p>What’s more</p>
<p>Previously, we assume the light is “accidentally” shot by uniform hemisphere sampling</p>
<p>Now we consider the radiance coming from two parts</p>
<ol start="0">
<li><font color="blue">light source</font> （direct, no need to have RR）</li>
<li><font color="orange">other reflections</font>（indirect, RR）</li>
</ol>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">shade(p,wo)
    # contribution from the light source
    Uniformly sample the light at x'' (pdf_light = 1 / A)               
    L_dir = L_i * f_r * cos θ * cos θ''  |x'' - p|^2 / pdf_light

    # contribution from other reflectors
    L_indir = 0.0
    Test Russian Roulette with probability P_RR
    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 /2pi)
    Trace a ray r(p, wi)
    if ray r hit a non-emmiting object at q
        L_indir =  shade (q,-wi)=f_r * cos θ /pdf_hemi/ P_RR
    Return L_dir + L_indir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>At last</p>
<p>One final thing：how do we know  if the sample on the light is not blocked or not？</p>
<p>Just revise the shade a little </p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">L_dir = 0.0
Uniformly sample the light at x'' (pdf_light = 1 / A) 
shoot a ray from p to x''
if the ray is not blocked in the middle
    L_dir =....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Some Side Notes</p>
<ol start="0">
<li>Consider if the most challenging in undergrad CS</li>
<li>Why? Physic, probability, calculus, coding </li>
<li>Learning PT will help you understand deeper in these</li>
</ol>
<p>Maybe the PT is not “introduction”, but it’s modern. And learning it will be rewarding also because it is almost 100% correct. </p>
</li>
<li><p>Ray tracing ： Previous vs. Modern Concepts</p>
<p>Previous ：Ray tracing  == Whitted-style ray tracing</p>
<p>Modern：<strong>The general solution of light transport</strong>, include （Unidirectional &amp; bidirectional）path tracing, photon mapping（光子映射）, Metropolis light transport ,VCM/UPBP  and etc</p>
</li>
<li><p>Something hasn’t covered / won’t cover</p>
<ol start="0">
<li>Uniformly sampling the hemisphere</li>
<li>Monte Carlo integration allows arbitrary pdfs - important sampling</li>
<li>Random numbers matter - low discrepancy sequences</li>
<li>can combine sample the hemisphere and the light - multiple imp.samplig</li>
<li>The radiance of a pixel is the average of radiance on all paths passing through it - pixel  reconstruction filter</li>
<li>The radiance of a pixel isn’t the color of a pixel - gamma correction, curves, color space</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="6-Materials-and-Appearances"><a href="#6-Materials-and-Appearances" class="headerlink" title="6. Materials and Appearances"></a>6. Materials and Appearances</h2><p><strong>What is Material in Computer Graphics?</strong></p>
<p><strong>Material == BRDF!</strong></p>
<ol start="0">
<li><p>Diffuse / Lambertian Material：</p>
</li>
<li><p>Light is equally reflected in each output direction. Suppose the incident lighting is <font color="red">uniform</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/DiffusAlsaaisd.png" alt="DiffusAlsaaisd"></p>
</li>
</ol>
<p>$$<br>L_o(\omega_o)=\int_{H^2}f_rL_i(\omega_i)\cos\theta_id\omega_i\\<br>=f_rL_i\int_{H^2}\cos\theta_id\omega_i\\<br>=\pi f_rL_i\\<br>f_r=\frac \rho \pi<br>$$</p>
<ol>
<li><p>Glossy material（BRDF）</p>
<p>Ideal reflective / refractive material（BSDF*）</p>
<p>Perfect Specular Reflection</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Perfect_specular_reflection.png" alt="Perfect_specular_reflection"></p>
<p>and then<br>$$<br>\omega _o+\omega _i=2\cos\theta \vec n = 2(\omega \cdot \vec n)\vec n\\<br>\omega _o=-\omega _i+2(\omega _i\cdot \vec n)\vec n<br>$$</p>
</li>
<li><p>Specular Refraction</p>
<p>In addition to reflecting off surface, light may be transmitted through surface.</p>
<p>Light refracts when it enters a new medium.   （Ocean：caustics)</p>
<p><strong>Snell’s Law</strong></p>
<p>Transmitted angle depends on </p>
<ol start="0">
<li><p>index of refraction （IOR） for incident ray</p>
</li>
<li><p>index of refraction （IOR） for exiting ray<br>$$<br>\eta_i\sin\theta_i=\eta_t\sin\theta_t\\<br>\phi_t=\phi_i\pm \pi<br>$$</p>
</li>
</ol>
<p><strong>Law of Refraction</strong><br>$$<br>\cos\theta_t=\sqrt {1-(\frac  {\eta_i}{\eta_t})^2(1-\cos^2\theta)i}<br>$$<br><strong>Total internal reflection</strong></p>
<p>When light is moving from a more optically dense medium to a less optically dense medium $\eta_i /\eta_t&gt;1$</p>
<p>Light incident on boundary from large enough angle will not exit medium</p>
<p><strong>Fresnel Reflection / Term</strong></p>
<p>Reflectance depends on incident angle（and polarization of light）</p>
<p>The formulae of it are<br>$$<br>R_s=\left|\frac {n_1\cos\theta_i-n_2\cos\theta_t}{n_1\cos\theta_i+n_2\cos\theta_t}\right|^2=\left|\frac {n_1\cos\theta_i-n_2 \sqrt {1-(\frac {\eta_1}{\eta_2})^2(1-\cos^2\theta})}{n_1\cos\theta_i+n_2\sqrt {1-(\frac{\eta_1}{\eta_2})^2(1-\cos^2\theta})} \right|^2\\R_p=\left|\frac {n_1\cos\theta_t-n_2\cos\theta_i}{n_1\cos\theta_t+n_2\cos\theta_i} \right|^2=\left|\frac{n_1\sqrt {1-(\frac  {\eta_1}{\eta_2})^2(1-\cos^2\theta_i)}-n_2\cos\theta_t}{n_1\sqrt {1-(\frac  {\eta_1}{\eta_2})^2(1-\cos^2\theta_i)}+n_2\cos\theta_t} \right|^2\\R_{eff}=\frac 12(R_s+R_p)<br>$$</p>
</li>
</ol>
<p>   It’s too difficult, there is an approximate - Schlick’s approximation $R(\theta)=R_0+(1-R_0)(1-\cos\theta)^5\ ,\ R_0=(\frac {n_1-n_2}{n_1+n_2})$</p>
<p>   <strong>Microfacet Material</strong></p>
<p>   Microfacet Theory</p>
<ol start="0">
<li><p>Rough surface - Macroscale is flat &amp; rough and microscale is bumpy &amp; <font color="red">specular</font></p>
</li>
<li><p>Individual elements of surface act like mirrors</p>
<p>Known as Microfacets and each microfacet has its own normal</p>
</li>
<li><p>Microfacet BRDF</p>
<p>Key：the <font color="red">distribution</font> of microfacets’ normals</p>
<ol start="0">
<li>Concentrated &lt;==&gt; glossy</li>
<li>Spread &lt;==&gt; diffuse</li>
</ol>
<p>The formula</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5CBRDF_MACUOFACTES.png" alt="BRDF_MACUOFACTES"><br>$$<br>f(i,o)=\frac {F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)}<br>$$<br>where $F$ is Fresnel term,  $G$ is shadowing-masking term and the $D$ is distribution of normals</p>
</li>
</ol>
<p>   <strong>Isotropic / Anisotropic Materials（BRDFs）</strong> 各向同性和各向异性</p>
<p>   Key: <font color="red">directionality</font> of underlying surface</p>
<p>   Anisotropic BRDFs: Reflection depends on azimuthal angle $\phi$ $f_r(\theta_i,\phi_i,\theta_r,\phi_r)\neq f_r(\theta_i,\theta_r,\phi_r-\phi_i)$</p>
<p>   Results from oriented microstructure of surface.</p>
<ol start="3">
<li><p>Properties of BRDFs</p>
<ol start="0">
<li><p>Non-negativity: $f_r(\omega_i\rightarrow\omega_r)\geq0$</p>
</li>
<li><p>Linearity: $L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i\rightarrow\omega_r)L_i(p,\omega_i)\cos\theta_id\omega_i$</p>
</li>
<li><p>Reciprocity principle: $f_r(\omega_r\rightarrow\omega_i)=f_r(\omega_i\rightarrow\omega_r)$</p>
</li>
<li><p>Energy conservation:$\forall\omega_r\int_{H^2}f_r(\omega_i\rightarrow\omega_r)\cos\theta_id\omega_i\leq1$</p>
</li>
<li><p>Isotropic vs. anisotropic</p>
<p>If isotropic $f_r(\theta_i,\phi_i,\theta_r,\phi_r)= f_r(\theta_i,\theta_r,\phi_r-\phi_i)$ . </p>
<p>Then from reciprocity $f_r(\theta_i,\theta_r,\phi_r-\phi_i)=f_r(\theta_i,\theta_r,\phi_i-\phi_r)=f_r(\theta_i,\theta_r,|\phi_r-\phi_i|)$</p>
</li>
</ol>
</li>
<li><p>Measuring BRDFs</p>
<ol start="0">
<li><p>Motivation:</p>
<p>Avoid need to develop / derive model - Automatically includes all of the scattering effects present</p>
<p>Can accurately render with real-world materials - Useful for product design, special effects …</p>
</li>
<li><p>Image-Based Measurement</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/BRDFMEASUREBASEDIMAGE.png" alt="BRDFMEASUREBASEDIMAGE" style="zoom:50%;">
</li>
<li><p>General approach</p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">for each outgoing direction wo
    move light to illuminate surface with a thin beam from wo
    for each incoming direction wi 
        move sencor to be at direction wi from surface
        measure incident radiance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Improving efficiency</p>
<ol start="0">
<li>Isotropic surfaces reduce dimensionality from 4D to 3D</li>
<li>Reciprocity reduces # of measurements by half</li>
<li>Clever optical systems</li>
</ol>
</li>
<li><p>Representing  Measured BRDFs</p>
<ol start="0">
<li><p>Compact representation</p>
</li>
<li><p>Accurate representation of measured data</p>
</li>
<li><p>Efficient evaluation for arbitrary pairs of directions</p>
</li>
<li><p>Good distributions available for importance sampling</p>
</li>
<li><p>Tabular Representation - store regularly-spaced samples in $(\theta_i,\theta_o,|\phi_i-\phi_o|)$（Better: reparameterize angles to better match  specularities）</p>
<p>Generally need to resample measured values to table. But it have very high storage requirements</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="7-Advanced-Topics-in-rendering"><a href="#7-Advanced-Topics-in-rendering" class="headerlink" title="7. Advanced Topics in rendering"></a>7. Advanced Topics in rendering</h2><h3 id="Advanced-Light-Transport"><a href="#Advanced-Light-Transport" class="headerlink" title="Advanced Light Transport"></a>Advanced Light Transport</h3><ol start="0">
<li><p>Biased vs. Unbiased Monte Carlo Estimators</p>
<ol start="0">
<li><p>An unbiased Monte Carlo technique does not have any systematic error </p>
<p>The expected value of an unbiased estimator will always be the correct value, no matter how many samples are used</p>
</li>
<li><p>Otherwise, biased</p>
<p>One special case, the expected value converges to the correct value as infinite #samples are used - <font color="red">consistent</font></p>
</li>
</ol>
</li>
<li><p>Unbiased light transport methods </p>
<ol>
<li><p>Bidirectional path tracing（BDPT）</p>
<ol start="0">
<li>Recall: a path connects the camera and the light</li>
<li>BDPT<ol start="0">
<li>Traces sub-paths from both the camera and the light</li>
<li>Connects the end points from both sub-paths</li>
<li>Suitable if the light transport is complex on the light’s side</li>
<li>Difficult to implement &amp; quite slow</li>
</ol>
</li>
</ol>
</li>
<li><p>Metropolis light transport （MLT）</p>
<ol start="0">
<li><p>Idea: Jumping from the current sample to the next with some PDF</p>
</li>
<li><p>It is good at locally exploring difficult light paths</p>
</li>
<li><p>Key: Locally perturb an existing path to get a new path</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Metropolis_light_transport.png" alt="Metropolis_light_transport"></p>
</li>
<li><p>It works great with difficult light paths but also unbiased</p>
</li>
<li><p>Disadvantage</p>
<ol start="0">
<li>Difficult to estimate the convergence rate</li>
<li>Does not guarantee equal convergence rate per pixel</li>
<li>So usually produces “dirty” results</li>
<li>Therefore, usually not used to render animations</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Biased light transport methods</p>
<ol>
<li><p>Photon Mapping</p>
<p>A biased approach &amp; a two-stage method and very good at handling Specular-Diffuse-Specular(SDS) paths and generating <font color="red">caustics</font></p>
<p><strong>Stage 0 - photon tracing</strong></p>
<p>Emitting photons from the light source, bouncing them around, then recording photons on diffuse surfaces</p>
<p><strong>Stage 1 - photon collection ( final gathering)</strong></p>
<p>Shoot sub-paths from the camera, bouncing them around, until they hit diffuse surfaces</p>
<p><strong>Calculation - <font color="red">local density estimation</font></strong></p>
<p><strong>idea</strong>: area with more photons should be brighter</p>
<p>For each shading point, find the nearest $N$ photons. Take the surface area that over</p>
<p><strong>Why biased?</strong></p>
<p>Because local Density estimation<br>$$<br>\frac {dN}{dA}\neq\frac{\Delta N}{\Delta A}<br>$$<br>But in the sense of limit, more photons emitted -&gt;The same $N$ photos covers a smaller $\Delta A$ , and the $\Delta A$ is  closer to $dA$. So, biased but consistent.</p>
<p><strong>An easier understanding bias in rendering</strong></p>
<p>Biased == blurry and consistent == not blurry with infinite #samples</p>
<p>*<em>not do a “const range” *</em></p>
</li>
<li><p>Vertex connection and merging</p>
<p>A combination of BDPT and Photon Mapping</p>
<p><strong>Key idea</strong></p>
<p>Let’s not waste the sub-paths in BDPT if their end points cannot be connected but can be merged and use photon mapping to handle the merging of nearby “photons”</p>
</li>
</ol>
</li>
<li><p>Instant radiosity （VPL / many light methods）</p>
<p>Sometimes also called many-light approaches</p>
<p><strong>Key idea</strong>: Lit surfaces can be treated as light sources</p>
<p><strong>Approach</strong>: Shoot light sub-paths and assume the end point of each sub-path is a Virtual Point Light (VPL), then render the scene as usual using these VPLs .</p>
<p><strong>Pro</strong> fast and usually gibes good results on diffuse scenes</p>
<p><strong>Cons</strong> Spikes will emerge when VPLs are close to shading points and cannot handle glossy materials</p>
</li>
</ol>
<h3 id="Advanced-Appearance-Modeling"><a href="#Advanced-Appearance-Modeling" class="headerlink" title="Advanced Appearance Modeling"></a>Advanced Appearance Modeling</h3><ol start="0">
<li><p>Non-surface models</p>
<p>Such like cloud or fog, at any point as light travels through a participating medium, it can be （partially） absorbed and scattered.</p>
<ol start="0">
<li><p>Participating media</p>
<p>Use Phase Function to describe the angular distribution of light scattering at any point $x$ with participating media.</p>
<p>Rendering</p>
<ol start="0">
<li>Randomly choose a direction to bounce</li>
<li>Randomly choose a distance to go straight </li>
<li>At each ‘shading pointy’, connect to the light</li>
</ol>
</li>
<li><p>Hair / fur / fiber（BCSDF）</p>
<ol start="0">
<li>Kajiaya-Kay Model</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Kajiaya-Ka_Model.png" alt="Kajiaya-Ka_Model" style="zoom:50%;">

<ol>
<li><p>Marschner Model</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Granular_material.png" alt="Granular_material" style="zoom:50%;">

<p>Glass-like cylinder: 3 types of light interactions: R, TT, TRT （reflection = R, transmission =T ）</p>
<ol start="2">
<li>Fur - Double Cylinder Model - Lobes</li>
</ol>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\Double_Cylinder_ModeLobes.png" alt="Double_Cylinder_ModeLobes" style="zoom:50%;">
</li>
</ol>
</li>
<li><p>Granular material（颗粒材质）</p>
<p>With<font color="red"> procedural</font> definition, we can avoid explicit modeling of all granules</p>
</li>
</ol>
</li>
<li><p>Surface models</p>
<ol start="0">
<li><p>Translucent material (BSSRDF)</p>
<p>Subsurface Scattering - Visual characteristics of many surfaces caused by light exiting at different points than it enters which violates a fundamental assumption of the BRDF.</p>
<p>BSSRDF: generalization of BRDF; exitant radiance at one point due to incident differential irradiance at another point: $S(x_i,\omega_i,x_o,\omega_o)$</p>
<p>Generalization of rendering equation: integrating over all points on the surface and all directions<br>$$<br>L(x_o,\omega_o)=\int_A \int_{H^2} (x_i,\omega_i,x_o,\omega_o)L_i(x_i,\omega_i)\cos \theta_id\omega_idA<br>$$<br><strong>Dipole Approximation</strong> - Approximate light diffusion by introducing two points sources.</p>
</li>
<li><p>cloth</p>
<p><strong>A collection of twisted fibers</strong></p>
<p>Given the weaving pattern, calculate the overall behavior and render using a BRDF.</p>
<p><strong>Render as Participating Media</strong></p>
<p>Properties of individual fibers &amp; their distribution -&gt; scattering parameters, render as a participating medium</p>
<p><strong>Render as Actual Fibers</strong></p>
</li>
<li><p>Detailed material （non-statistical BRDF）</p>
<p><strong>Difficult</strong> Path sampling problem</p>
<p><strong>Solution</strong> BRDF over a pixel</p>
<p>p-NDFs have sharp features</p>
</li>
</ol>
</li>
<li><p>Procedural appearance - We can define details without textures by computing a noise function on the fly. 3D noise -&gt; internal structure if cut or broken</p>
<pre class="line-numbers language-pseudocode"><code class="language-pseudocode">if noise(x, y, z) > threshold reflectance = 1
else reflectance = 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>complex noise function can be very powerful, such like mountain, ocean sea face of wood texture.</p>
</li>
</ol>
<h2 id="8-Cameras-Lenses-and-Light-Fields"><a href="#8-Cameras-Lenses-and-Light-Fields" class="headerlink" title="8. Cameras, Lenses and Light Fields"></a>8. Cameras, Lenses and Light Fields</h2><p><strong>Imaging = Synthesis +Capture. but how to capture? By cameras!</strong></p>
<h3 id="Pinholes-amp-Lenses-Form-Image-on-Sensor"><a href="#Pinholes-amp-Lenses-Form-Image-on-Sensor" class="headerlink" title="Pinholes &amp; Lenses Form Image on Sensor"></a>Pinholes &amp; Lenses Form Image on Sensor</h3><img src="C:\Users\Y\Desktop\blog_pic\OOCG\Pinhole_camera.png" alt="Pinhole_camera" style="zoom:67%;">

<ol start="0">
<li><p>Composition</p>
<ol start="0">
<li>shutter: exposes sensor for precise duration </li>
<li>Sensor Accumulates irradiance during exposure</li>
</ol>
</li>
<li><p>Why Not Sensors Without Lense</p>
<p>Each sensor point would integrate light all points on the object, so all pixel values would be similar.</p>
</li>
</ol>
<h3 id="Field-of-View（FOV）视场"><a href="#Field-of-View（FOV）视场" class="headerlink" title="Field of View（FOV）视场"></a>Field of View（FOV）视场</h3><ol start="0">
<li><p>Effect of Focal Length on FOV</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\FOV_EFFECT.png" alt="FOV_EFFECT" style="zoom:50%;">

<p>for a fixed sensor size, decreasing the focal length increases the field of view.<br>$$<br>FOV = 2\arctan(\frac h{2f})<br>$$</p>
</li>
<li><p>Focal Length v. Field of View</p>
<ol start="0">
<li>For historical reasons, it is common to refer to angular field of view by focal length of a lens used on a 35mm-format film （36 x 24mm）</li>
<li>Careful! When we say current cell phones have approximately 28mm “equivalent” focal length, this uses the above convention.</li>
</ol>
</li>
<li><p>To maintain FOV, decrease focal length of lens in proportion to width/height of sensor</p>
</li>
</ol>
<h3 id="Exposure"><a href="#Exposure" class="headerlink" title="Exposure"></a>Exposure</h3><ol start="0">
<li><p>Basic</p>
<ol start="0">
<li>$H=T\times E$</li>
<li>Exposure = time $\times$ irradiance</li>
<li>Exposure time $T$ - Controlled by shutter</li>
<li>Irradiance $E$<ol start="0">
<li>Power of light falling on a unit area of sensor</li>
<li>Controlled by lens aperture and focal length</li>
</ol>
</li>
</ol>
</li>
<li><p>Exposure Controls in Photography</p>
<ol start="0">
<li><p>Aperture size</p>
<p>Change the f-stop by opening / closing the aperture （if camera has iris control）</p>
</li>
<li><p>Shutter speed</p>
<ol start="0">
<li><p>Definition:</p>
<p>Change the duration the sensor pixels integrate light</p>
</li>
<li><p>Side Effect of Shutter Speed:</p>
<ol start="0">
<li>Motion blur: handshake, subject movement - Doubling shutter time doubles motion blur</li>
<li>Rolling shutter: different parts of photo taken at different times</li>
</ol>
</li>
</ol>
</li>
<li><p>ISO gain （感光度）</p>
<p>Change the amplification（analog and/or digital）between sensor values and digital image values</p>
</li>
</ol>
</li>
<li><p>ISO(Gain)</p>
<p>Third variable for exposure;</p>
<p>Film: trade sensitivity for grain</p>
<p>Digital: trade sensitivity for noise</p>
<pre><code>   0. Multiply signal before analog-to-digital conversion
         1. Linear effect （ISO 200 needs half the light as ISO 100）</code></pre></li>
<li><p>F-Number（F-stop）: Exposure Levels</p>
<p>Written as FN or F/N. N is the f-number, the understanding is that the inverse-diameter of a round aperture</p>
</li>
<li><p>Constant Exposure: F-Stop vs Shutter Speed</p>
<p>If the exposure is too bright/dark, may need to adjust f-stop and/or shutter up/down.</p>
<p>Photographers must trade off depth of field（景深） and motion blur for moving subjects</p>
</li>
<li><p>High-Speed Photography</p>
<p>Normal exposure = extremely fast shutter speed $\times$（large aperture and/or high ISO）</p>
</li>
<li><p>Long-Exposure Photography</p>
</li>
</ol>
<h3 id="Thin-Lens-Approximation"><a href="#Thin-Lens-Approximation" class="headerlink" title="Thin Lens Approximation"></a>Thin Lens Approximation</h3><p>We just illustrate the ideal thin lens - focal point, and there have 3 properties </p>
<p>a. All parallel rays entering a lens pass through its focal point</p>
<p>b. All rays through a focal point will be in parallel after passing the lens.</p>
<p>c. Focal length can be arbitrarily changed </p>
<ol start="0">
<li><p>The Thin Lens Equation</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\The_Thin_Lens_Equation.png" alt="The_Thin_Lens_Equation" style="zoom:50%;">
$$
\frac 1f=\frac 1{z_i}+\frac 1{z_o}
$$
</li>
<li><p>Defocus Blur</p>
<ol start="0">
<li><p>Circle of Confusion（CoC）Size</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\Circle_OF_Clin.png" alt="Circle_OF_Clin" style="zoom:50%;">

<p>Circle of confusion is <font color="red"> proportional to the size of the aperture</font> because of<br>$$<br>\frac CA=\frac {d’}{z_i}=\frac {|z_s-z_i|}{z_i}<br>$$</p>
</li>
<li><p>CoC vs. Aperture Size</p>
<ol start="0">
<li><p>Revisiting F-Number </p>
<ol start="0">
<li>Formal definition: The f-number of a lens is defined as the focal length divided by the diameter of the aperture</li>
<li>Common f-stops on real lenses: 1.4,2, 2.8, 4.0, 5.6, 8, 11, 16, 22, 32</li>
<li>An f-stop of 2 is sometimes written f/2, reflecting the fact that the absolute aperture diameter (A) can be computed by dividing focal length (f) by the relative aperture (N).</li>
</ol>
</li>
<li><p>Size of CoC is inversely Proportional to F-stop<br>$$<br>C=A\frac {|z_s-z_i|}{z_i}=\frac fN\frac {|z_s-z_i|}{z_i}<br>$$</p>
</li>
</ol>
</li>
<li><p>Ray Tracing ideal Thin Lenses</p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Ray_Tracing_ideal_Thin_Lenses.png" alt="Ray_Tracing_ideal_Thin_Lenses" style="zoom:50%;">

<ol start="0">
<li><p>（One possible）Setup:</p>
<ol start="0">
<li><p>Choose sensor size, lens focal length and aperture size</p>
</li>
<li><p>Choose depth of subject of interest $z_o$</p>
</li>
<li><p>Calculate corresponding depth of sensor $z$; from thin lens equation（focusing）</p>
</li>
</ol>
</li>
<li><p>Rendering</p>
<ol start="0">
<li>For each pixel x’ on the sensor （actually film）</li>
<li>Sample random points x’’ on lens plane</li>
<li>You know the ray passing through the lens will hit x’’’（using the thin lens formula） </li>
<li>estimate radiance on ray x’’-&gt;x’’’</li>
</ol>
</li>
</ol>
</li>
<li><p>Depth of Field</p>
<p>Set circle of confusion as the maximum permissible blur spot on the image plane that will appear sharp under final viewing conditions</p>
<ol start="0">
<li><p>Depth of Field （FYI）</p>
<p><img src="C:%5CUsers%5CY%5CDesktop%5Cblog_pic%5COOCG%5CFVI.png" alt="FVI"><br>$$<br>D_F=\frac {D_sf^2}{f^2-NC(D_S-f)},D_N=\frac {D_sf^2}{f^2+NC(D_S-f)}<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Light-Field-Lumigraph（Temporary-omission）"><a href="#Light-Field-Lumigraph（Temporary-omission）" class="headerlink" title="Light Field / Lumigraph（Temporary omission）"></a>Light Field / Lumigraph（Temporary omission）</h3><h2 id="9-Color-and-Perception"><a href="#9-Color-and-Perception" class="headerlink" title="9. Color and Perception"></a>9. Color and Perception</h2><ol start="0">
<li><p>The Visible Spectrum of Light</p>
<p>Electromagnetic radiation  </p>
</li>
<li><p>Spectral Power Distribution（SPD） - Salient property in measuring light</p>
<ol start="0">
<li>The amount of light present at each wavelength</li>
<li>Units<ol start="0">
<li>radiometric units / nanometer （e.g. watts / nm）</li>
<li>Can also be unit-less</li>
</ol>
</li>
<li>Often use “relative units” scaled to maximum wavelength for comparison across wavelengths when absolute units are not important</li>
</ol>
</li>
<li><p>What is Color?</p>
<ol start="0">
<li><p>Preconcepts</p>
<ol start="0">
<li><p>Color is a phenomenon of human perception; it is not a universal property of light</p>
</li>
<li><p>Different wavelengths of light are not “colors”</p>
</li>
</ol>
</li>
<li><p>About Human Eye（omission）</p>
<ol start="0">
<li><p>Spectral Response of Human Cone Cells - Three types of cone cells: S, M and L （corresponding to peak response at short, medium and long wavelengths） </p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\Spectral_Response.png" alt="Spectral_Response" style="zoom: 67%;">
</li>
</ol>
</li>
<li><p>Tristimulus Theory of Color</p>
<ol start="0">
<li><p>According to the Spectral Response chart, we have tree detectors each with a different spectral response curve<br>$$<br>S=\int r_S(\lambda)s(\lambda)d\lambda<br>\\<br>M=\int r_M(\lambda)s(\lambda)d\lambda<br>\\<br>L=\int r_L(\lambda)s(\lambda)d\lambda<br>$$<br>（吐槽：眼睛都能自动算积分，脑子却不行）</p>
<p>The Human Visual System</p>
<p>Human eye does not measure and brain does not receive information about each wavelength of light.</p>
<p>Rather, <font color="red">the eye “sees” only three response value（S,M,L）</font> and this is only info available to brain</p>
</li>
<li><p>Metamerism（同色异谱）</p>
<p>Metamers are two different spectra（$\infty$-dim）that project to the same (S,M,L) (3-dim) response. These will appear to have the same color to a human<br>The existence of metamers is critical to color reproduction</p>
<ol start="0">
<li>Don’t have to reproduce the full spectrum of a real world<br>scene</li>
<li>Example: A metamer can reproduce the perceived color of<br>a real-world scene on a display with pixels of only three<br>colors</li>
</ol>
<p>The theory behind <font color="red"> color matching </font></p>
</li>
<li><p>Color Reproduction / Matching</p>
<ol start="0">
<li><p>Additive Color</p>
<p>Given a set of primary lights, each with its own spectral distribution. For example, RGB display pixels<br>$$<br>s_R(\lambda),s_G(\lambda)，s_B(\lambda)<br>$$<br>Adjust the brightness of these lights and add them together<br>$$<br>Rs_R(\lambda)+Gs_G(\lambda)+Bs_B(\lambda)<br>$$<br>The color is now described by the scalar values: R,G,B</p>
<p><strong>CIE RGB Color Matching Experiment</strong>:</p>
<p>Same setup as additive color matching before, but primaries are monochromatic light （single wavelength）</p>
<p><strong>Function:</strong></p>
<p>Graph plots how much of each CIE RGB primary light must be combined to match a monochromatic light of wavelength given on x-axis. <strong>Be careful that these are not response curves or spectral</strong></p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Color_Matching_Experiment.png" alt="Color_Matching_Experiment">

<p>For any spectrum $s$, the perceived color is matched by the following formulas for scaling the CIE RGB primaries<br>$$<br>R_{CIE\ RGB}=\int_{\lambda} s(\lambda)\overline r(\lambda)d\lambda<br>\\<br>G_{CIE\ RGB}=\int_{\lambda} s(\lambda)\overline g(\lambda)d\lambda<br>\\<br>G_{CIE\ RGB}=\int_{\lambda} s(\lambda)\overline b(\lambda)d\lambda<br>$$</p>
</li>
</ol>
</li>
<li><p>Standard Color Spaces</p>
<ol start="0">
<li><p>Standardized RGB</p>
<p>It makes a particular monitor RGB standard,  an other color devices simulate that monitor by calibration, a widely adopted today and the gamut（色域） is limited</p>
</li>
<li><p>CIE XYZ</p>
<p>Imaginary set of standard color primaries X, Y, Z</p>
<ol start="0">
<li>Primary colors with these matching functions do not exist</li>
<li>Y is luminance（brightness regardless of color）</li>
</ol>
<p>Designed such that</p>
<ol start="0">
<li>Matching function are strictly positive</li>
<li>Span all observable colors</li>
</ol>
<p>Separating Luminance, Chromaticity</p>
<p>Luminance Y, Chromaticity: x, y, z, defined as<br>$$<br>x=\frac X{X+Y+Z}<br>Y=\frac Y{X+Y+Z}<br>Z=\frac Z{X+Y+Z}<br>$$</p>
<ol start="0">
<li>Since $x+y+z=1$, we only need to record two of the three</li>
<li>Usually choose $x$ and $y$, leading to $(x,y)$ coords at a specific brightness $Y$</li>
</ol>
<p>Then we will get the <strong>CIE Chromaticity Diagram</strong></p>
<img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/CIE_XYZ_DIAGRAM.png" alt="CIE_XYZ_DIAGRAM">

<p>The curved boundary named spectral locus and it corresponds to monochromatic light（each point representing a pure color of a single wavelength）</p>
</li>
<li><p>Gamut（色域）</p>
<p>Gamut is the set of chromaticities generated by a set of color primaries. Different color spaces represent different ranges of colors. So they have different gamuts, i.e. they cover different regions on the chromaticity diagram</p>
</li>
<li><p>Perceptually Organized Color Spaces</p>
<ol start="0">
<li><p>HSV Color Space（Hue-Saturation-Value）</p>
<p>Axes correspond to artistic characteristics of color, it is widely used in a “color picker”</p>
<ol start="0">
<li>Hue（色调）<ol start="0">
<li>the “kind” of color, regardless of attributes</li>
<li>colorimetric correlate: dominant wavelength</li>
<li>artist’s correlate: the chosen pigment color</li>
</ol>
</li>
<li>Saturation （饱和度）<ol start="0">
<li>the “colorfulness”</li>
<li>colorimetric correlate: purity</li>
<li>artist’s correlate: fraction of paint from the colored tube</li>
</ol>
</li>
<li>Lightness (or value) （亮度）<ol start="0">
<li>the overall amount of light</li>
<li>colorimetric correlate: luminance</li>
<li>artist’s correlate: tints are lighter, shades are darker</li>
</ol>
</li>
</ol>
</li>
<li><p>CIELAB space（AKA L* a * b*）</p>
<p>A commonly used color space that strives for perceptual uniformiity</p>
<p>L* is lightness（Brightness）</p>
<p>a* and b* are color-opponent pairs, a* is red-green and b* is blue-yellow</p>
<p><strong>Opponent Color Theory</strong></p>
<p>one piece of evidence: you can have a light green, a dark green, a yellow-green, or a blue-green, but you can’t have a reddish green (just doesn’t make sense). Thus red is the <strong>opponents</strong> to green</p>
</li>
</ol>
</li>
<li><p>Everything is Relative</p>
</li>
<li><p>CMY A Subtractive Color Space</p>
<p>Subtractive color model: the more you mix, the darker it will be </p>
<p>C=Cyan, M=Magenta and Y=Yellow. </p>
<p>Be careful that there have another name CMYK, but it just used in printing because the color is expensive, black is cheap, but if we use color to get the black, it is dear. So use another K=Key means black can decrease the cost in printing.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="10-Animation"><a href="#10-Animation" class="headerlink" title="10. Animation"></a>10. Animation</h2><p><strong>“Bring things to life”</strong> - Communication tool + Aesthetic issues often dominate technical issues</p>
<p><strong>An extension of modeling</strong> - Represent scene models as a function of time </p>
<p><strong>Output</strong>: Sequence of images that when viewed sequentially provide a sense of motion</p>
<p>File -24frames per second（FPS）, video（in general）: 30 FPS，virtual reality 90 FPS</p>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>First Hand-Drawn Feature-Length（&gt;40mins）Animation - <em>Snow White and the Seven Dwarfs</em></p>
<p>First Digital-Computer-Generated Animation: 1963（vector display）</p>
<p>Early Computer Animation：1972</p>
<p>First CG Feature-Length Film：<em>Toy Story</em></p>
<h3 id="Keyframe-animation"><a href="#Keyframe-animation" class="headerlink" title="Keyframe animation"></a>Keyframe animation</h3><p>Definition: The most important frame in the sequence of frame which illustrate the most important states.</p>
<p>Keyframe Interpolation: Linear interpolation , splines for smooth / controllable interpolation and etc.</p>
<h3 id="Physical-simulation"><a href="#Physical-simulation" class="headerlink" title="Physical simulation"></a>Physical simulation</h3><p>Newton’s Law $F=ma$</p>
<p>Physically Based Animation: Generate motion of objects using numerical simulation</p>
<p><strong>Mass Spring System</strong></p>
<ol start="0">
<li><p>A Simple Spring </p>
<p>Idealized spring（$a,b$ are 2 positions）<br>$$<br>f_{a\rightarrow b}=k_s(b-a)\\<br>f_{a\rightarrow b}=-f_{b\rightarrow a}<br>$$<br>Force pulls points together, strength proportional to displacement（Hooke’s Low）, $k_s$ is a spring coefficient - stiffness</p>
</li>
<li><p>Non-Zero Length spring<br>$$<br>f(a\rightarrow b)=k_s\frac {b-a}{||b-a||}(|b-a||-l)<br>$$<br>where $l$ is rest length</p>
</li>
<li><p>Introducing Energy Loss</p>
<p>Simple motion damping $f=-k_d\dot b$</p>
<ol start="0">
<li>Behaves like viscous drag on motion</li>
<li>Slows down motion in the direction of velocity</li>
<li>$k_d$ is a damping coefficient</li>
</ol>
<p>Problem: slow down <strong>all</strong> motion </p>
</li>
<li><p>Internal Damping</p>
<p>Damp only the internal, spring-driven motion<br>$$<br>f_b=-k_d\frac {b-a}{||b-a||}(\dot b -\dot a)\frac {b-a}{||b-a||}<br>$$<br>where $k_d$ is damping force applied on b,$(\dot b -\dot a)$ is the relative velocity of $b$, assuming $a$ is static（vector）, the $\frac {b-a}{||b-a||}(\dot b -\dot a)$ is <font color="red">relative velocity projected to the direction from $a$ to $b$ （scalar）</font>and $\frac {b-a}{||b-a||}$ is direction from $a$ to $b$</p>
<p>Viscous drag only on change in spring length, it won’t slow group motion for the spring system（e.g. global translation or rotation of the group）</p>
<p>Note that this is only one specific type of damping</p>
</li>
<li><p>Structures from Spring</p>
<p>Behavior is determined by structure linkages</p>
</li>
</ol>
<p><strong>Particle System</strong></p>
<ol start="0">
<li><p>Definition</p>
<p>Model dynamical systems as collections of large numbers of particles.</p>
<p>Each particle’s motion is defined by a set of physical （or non-physical） forces</p>
</li>
<li><p>Popular technique in graphics and games</p>
<ol start="0">
<li>Easy to understand, implement</li>
<li>Scalable: fewer particles for speed, more for higher complexity</li>
</ol>
</li>
<li><p>Challenges</p>
<ol start="0">
<li>May need many particles （e.g. fluids）</li>
<li>May need acceleration structures （e.g. to find nearest particles for interactions）</li>
</ol>
</li>
<li><p>For each frame in animation</p>
<ol start="0">
<li>[If needed] Create new particles</li>
<li>Calculate forces on each particle</li>
<li>Update each particle’s position and velocity</li>
<li>[If needed] Remove dead particles</li>
<li>Render particles</li>
</ol>
</li>
<li><p>Forces</p>
<ol start="0">
<li>Attraction and repulsion forces</li>
<li>Damping forces</li>
<li>Collisions</li>
</ol>
</li>
</ol>
<h3 id="Kinematics"><a href="#Kinematics" class="headerlink" title="Kinematics"></a>Kinematics</h3><ol start="0">
<li><p>Forward Kinematics</p>
<ol start="0">
<li>Articulated skeleton<ol start="0">
<li>Topology（what’s connected to what）</li>
<li>Geometric relations from joints</li>
<li>Tree structure （in absence of loops）</li>
</ol>
</li>
<li>Joint types<ol start="0">
<li>Pin （1D rotation）</li>
<li>Ball （2D rotation）</li>
<li>Prismatic joint （translation）</li>
</ol>
</li>
<li>Strengths<ol start="0">
<li>Direct control is convenient</li>
<li>Implementation is straightforward</li>
</ol>
</li>
<li>Weaknesses<ol start="0">
<li>Animation may be inconsistent with physics</li>
<li>Time consuming for artists</li>
</ol>
</li>
</ol>
</li>
<li><p>Inverse Kinematics</p>
<p>Provide the end point, the procession of arrive to the end point by auto.</p>
<ol start="0">
<li>Hard <ol start="0">
<li>Calculate hard</li>
<li>Multiple solutions</li>
<li>Solutions may not exist</li>
</ol>
</li>
<li>Numerical solution to general N-link IK problem<ol start="0">
<li>Choose an initial configuration</li>
<li>Define an error metric （e.g. square of distance between goal and current position）</li>
<li>Compute gradient of error as function of configuration</li>
<li>Apply gradient descent （or Newton’s method, or other optimization procedure）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Rigging"><a href="#Rigging" class="headerlink" title="Rigging"></a>Rigging</h3><p>Rigging is a set of higher level controls on a character that allow more rapid &amp; intuitive modification of pose, deformations, expression, etc.</p>
<ol start="0">
<li><p>Important</p>
<ol start="0">
<li>Like strings on a puppet </li>
<li>Captures all meaningful character changes</li>
<li>Varies from character to character</li>
</ol>
</li>
<li><p>Expensive to create</p>
<ol start="0">
<li>Manual effort</li>
<li>Requires both artistic and technical training</li>
</ol>
</li>
<li><p>Blend Shape</p>
<p>Instead of skeleton, interpolate directly between surfaces.</p>
<p>Simplest scheme: take linear combination of vertex positions.</p>
<p>Spline used to control choice of weights over time</p>
</li>
</ol>
<h3 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h3><p>Data-driven approach to creating animation sequences </p>
<ol start="0">
<li>Record real-world performances</li>
<li>Extract pose as a function of time from the date collected</li>
</ol>
<p>Strengths</p>
<ol start="0">
<li>Can capture large amounts of real data quickly</li>
<li>Realism can be high</li>
</ol>
<p>Weaknesses</p>
<ol start="0">
<li>Complex and costly set-ups</li>
<li>Captured animation may not meet artistic needs, requiring alterations</li>
</ol>
<p>Optical Motion Capture</p>
<ol start="0">
<li>Markers on subject</li>
<li>Positions by triangulation from multiple cameras</li>
<li>Many cameras ,240hz, occlusions are difficult</li>
</ol>
<p>Challenges of Facial Animation - Uncanny Valley</p>
<p>It is in robotics and graphics. As artificial character appearance approaches human realism, our emotional response goes negative, until it achieves a sufficiently convincing level of realism in expression</p>
<h3 id="Explicit-Euler-Method"><a href="#Explicit-Euler-Method" class="headerlink" title="Explicit Euler Method"></a>Explicit Euler Method</h3><ol start="0">
<li><p>single particle simulation</p>
<p>First study motion of a single particle, later generalize to a multitude of particles.</p>
<p>To start, assume motion of particle determined by a velocity vector field that is a function of position and time: $v(x,t)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/image-20200507145504362.png" alt="image-20200507145504362"></p>
<ol start="0">
<li><p>Ordinary Differential Equation（ODE）</p>
<p>Computing position of particle over time requires solving a first-order ordinary differential equation<br>$$<br>\frac {dx}{dt}=\dot x=v(x,t)<br>$$<br>“First-order” refers to the first derivative being taken.</p>
<p>“Ordinary” means no “partial” derivatives</p>
<p>Solving for particle position that we can solve the ODE, subject to a given initial particle position $x_0$, by using forward numerical integration.</p>
</li>
<li><p>Euler’s Method</p>
<p>Euler’s Method （a.k.a. Forward Euler, Explicit Euler）It is a simple iterative method, commonly used,  inaccurate and most often goes <font color="red">unstable</font> method<br>$$<br>x^{t+\Delta t}=x^t+\Delta t\dot x^t\\\dot x^{t+\Delta t}=\dot x^t+ \Delta t \ddot x^t<br>$$<br><strong>Errors</strong></p>
<p>With numerical integration, errors accumulate Euler integration is particularly bad, </p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\EULLER_ERROR1.png" alt="EULLER_ERROR1" style="zoom:67%;">

<p><strong>In stability of the Euler Method</strong></p>
<p>The Euler method（explicit / forward）: $x^{t+\Delta t}=x^t+\Delta tv(x,t)$</p>
<p>Two key problems</p>
<ol start="0">
<li>Inaccuracies increase as time step $\Delta t$ increases</li>
<li>Instability is a common, serious problem that can cause simulation to diverge</li>
</ol>
<p><strong>Conclusion of Errors and Instability</strong></p>
<p>Solving by numerical integration with finite differences leads to two problems</p>
<p><strong>Errors</strong></p>
<ol start="0">
<li>Errors at each time step accumulate. Accuracy decreases as simulation proceeds</li>
<li>Accuracy may not be critical in graphics applications</li>
</ol>
<p><strong>Instability</strong></p>
<ol start="0">
<li>Errors can compound, causing the simulation to diverge even when the underlying system dose not.</li>
<li>Lack of stability is a fundamental problem in simulation, and cannot be ignored</li>
</ol>
</li>
<li><p>Some Methods to Combat Instability</p>
<ol start="0">
<li><p>Midpoint method / Modified Euler - Average velocities at start and endpoint</p>
<ol start="0">
<li><p>Idea - Compute Euler step, compute derivative at midpoint of Euler step. Then update position using midpoint derivative<br>$$<br>x_{mid}=x(t)+\frac {\Delta t}2\cdot v(v(x),t)\\<br>x(t+\Delta t)=x(t)+\Delta t \cdot v(x_{mid},t)<br>$$</p>
</li>
<li><p>Modified Euler - Average velocity at start and end of step. It is better results than before<br>$$<br>x^{t+\Delta t}=x^t+\Delta t \dot x^t+\frac {(\Delta t)^2}2\ddot x^t<br>$$</p>
</li>
</ol>
</li>
<li><p>Adaptive step size - Compare one step and two half-steps, recursively, until error is acceptable</p>
<ol start="0">
<li><p>Idea - Technique for choosing step size based on error estimate. It is practical but may need very small steps</p>
<p>Repeat until error is below threshold</p>
<ol start="0">
<li>Compute $x_T$ an Euler step, size $T$</li>
<li>Compute $X_{τ/2}$ two Euler steps, size $\frac T2$</li>
<li>Compute error $x_T - x_{T/2}$</li>
<li>If （error &gt; threshold）reduce step size else try again</li>
</ol>
</li>
</ol>
</li>
<li><p>Implicit methods - Use the velocity at the next time step（hard）</p>
<p>It is informally called backward methods and use derivatives in the future, fore the current step<br>$$<br>x^{t+\Delta t}=x^t+\Delta t\dot x^{t+\Delta t}\\\dot x^{t+\Delta t}=\dot x^t+ \Delta t \ddot x^{t+\Delta t}<br>$$<br>It should solve nonlinear problem for $x^{t+\Delta t}$ and $\dot x^{t+\Delta t}$ but it hard. We can use root-finding algorithm such like Newton’s method, and it will offer much better stability</p>
</li>
<li><p>Position-based / Verlet integration  - Constrain positions and velocities of particles after time step</p>
<ol start="0">
<li>Idea:<ol start="0">
<li>After modified Euler forward-step, constrain positions of particles to prevent divergent, unstable behavior. By using constrained positions to calculate velocity</li>
<li>Both of these ideas will dissipate energy, stabilize</li>
</ol>
</li>
<li>Pros / cons<ol start="0">
<li>Fast and simple</li>
<li>Not physically based, dissipates energy（error）</li>
</ol>
</li>
</ol>
</li>
<li><p>Stability<br>We use the local truncation error（every step）/ total accumulated error（overall）. It absolute values do not matter, but the orders w.r.t step. </p>
<p>The implicit Euler has order 1, which means that （h is the step, i.e. $\Delta t$）</p>
<ol start="0">
<li>Local truncation error: $O(h^2)$ </li>
<li>Global truncation error: $O(h)$ </li>
</ol>
<p>Understanding of $O(h)$ - if we halve $h$, we can expect the error to halve as well</p>
</li>
<li><p>Runge-Kutta Families</p>
<p>A family of advanced methods for solving ODEs , especially good at dealing with non-linearity. It’s order-four version is the most widely used, a.k.a. RK4<br>$$<br>y_{n+1}=y_n+\frac 16h(k_1+2k_2+2k_3+k_4)\\<br>t_{n+1}=t_n+h<br>$$<br>where<br>$$<br>k_1=f(t_n,y_n),k_2=f(t_n+\frac h2,y_n+h\frac {k_1}2)\\<br>k_3=f(t_n+\frac h2,y_n+h\frac{k_2}2)\\<br>k_4=f(t_n+h,y_n+hk_3)<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Rigid-Body-Simulation"><a href="#Rigid-Body-Simulation" class="headerlink" title="Rigid Body Simulation"></a>Rigid Body Simulation</h3><p>Simple case: Similar to simulating a particle, just consider a bit more properties</p>
<img src="C:\Users\Y\Desktop\blog_pic\OOCG\Rigid_Body_Simulation.png" alt="Rigid_Body_Simulation" style="zoom: 50%;">

<h3 id="Fluid-simulation"><a href="#Fluid-simulation" class="headerlink" title="Fluid simulation"></a>Fluid simulation</h3><ol start="0">
<li><p>A Simple Position - Based Method</p>
<p>Key idea - assuming water is composed of small rigid-body spheres, and the water cannot be compressed.</p>
<p>So, as long as the density changes somewhere, it should be “corrected” via changing the positions of particles</p>
<p>You need to know the gradient of the density anywhere w.r.t. each particle’s position and us gradient descent.</p>
</li>
<li><p>Eulerian（网格法） vs. Lagrangian（质点法）</p>
<p>Two different views to simulating large collections of matters.</p>
</li>
<li><p>Material Point Method（MPM）</p>
<p>Hybrid, combining Eulerian and Lagrangian views</p>
<ol start="0">
<li>Lagrangian: consider particles carrying material properties</li>
<li>Eulerian: use a grid to do numerical integration</li>
<li>Interaction: particles transfer properties to the grid, grid performs update, then interpolate back to particles</li>
</ol>
</li>
</ol>
<p>OK, 整个课程的知识总结已经完成，现在只剩下一些修补了（主要是一些图还没有上传的图床里面）后续的学习可以考虑 OpenGL或者DirectX，若要学习几何相关，微分几何，拓扑，流形也是需要涉及的；想要对光线更多的了解，可以考虑了解光线与传播。</p>
<p>下一次类似的大型内容应该是基于Python的模拟仿真内容了，六月一号见</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://astrojoke.github.io" rel="external nofollow noreferrer">AleXandrite</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://astrojoke.github.io/2020/05/02/overview-of-computer-graphics/">https://astrojoke.github.io/2020/05/02/overview-of-computer-graphics/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://astrojoke.github.io" target="_blank">AleXandrite</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">
                                    <span class="chip bg-color">图形学</span>
                                </a>
                            
                                <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                                    <span class="chip bg-color">基础知识</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">我觉得没有人会给我打赏</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/05/02/luo-gu-guan-fang-ti-dan-xian-xing-biao-ti-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="洛谷官方提单——线性表题解">
                        
                        <span class="card-title">洛谷官方提单——线性表题解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            基本的线性表运用
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-05-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="post-category">
                                    算法和程序设计
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">
                        <span class="chip bg-color">编程算法题解</span>
                    </a>
                    
                    <a href="/tags/%E6%B4%9B%E8%B0%B7/">
                        <span class="chip bg-color">洛谷</span>
                    </a>
                    
                    <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">
                        <span class="chip bg-color">线性表</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/05/02/qing-hua-mooc-tu-xing-xue-ji-chu-zhen-shi-gan-he-fei-zhen-shi-gan/">
                    <div class="card-image">
                        
                        <img src="https://cdn.jsdelivr.net/gh/AstroJoke/Blog_Image/images/Cover0.jpg" class="responsive-img" alt="清华MOOC图形学基础：真实感和非真实感">
                        
                        <span class="card-title">清华MOOC图形学基础：真实感和非真实感</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            真实感和非真实感相关
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-05-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="post-category">
                                    图形学
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">
                        <span class="chip bg-color">图形学</span>
                    </a>
                    
                    <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                        <span class="chip bg-color">基础知识</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://astrojoke.github.io" target="_blank">AleXandrite</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">131.7k</span>&nbsp;字
            
            
            
            
            
            
                <span id="busuanzi_container_site_pv" style='display:none'>
                        <i class="fa fa-heart-o"></i>
                        本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
             
             
                <span id="busuanzi_container_site_uv" style='display:none'>
                       人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/AstroJoke" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2829799409@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2829799409" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2829799409" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>

<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);  // 50ms周期检测函数
        var pvcountOffset = 0;  // 初始化首次数据
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    });
</script>




    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <script type="text/javascript">
        var OriginTitile=document.title,st;
        document.addEventListener("visibilitychange",function(){
            document.hidden?(document.title="ヽ(●-`Д´-)ノ崩溃啦",clearTimeout(st)):(document.title="(Ő∀Ő3)ノ骗你的",st=setTimeout(function(){document.title=OriginTitile},3e3))
        })
    </script>

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
