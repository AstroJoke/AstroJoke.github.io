<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>洛谷官方题单——模拟与高精度题解</title>
      <link href="/2020/04/18/luo-gu-guan-fang-ti-dan-mo-ni-yu-gao-jing-du-ti-jie/"/>
      <url>/2020/04/18/luo-gu-guan-fang-ti-dan-mo-ni-yu-gao-jing-du-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>模拟是指的是按照题目给的要求一步一步的考虑各种条件，不需要进行任何花里胡哨的其他操作就可以做出来的题，但是这些题有一个很大的特点：代码量很大且边界条件多，因此在WA了之后查找自己错误的地方会比较麻烦。</p><p>而高精度则是我们模拟数字的加减乘除。由于在C/C++等某些编程语言中，在语言设计的时候都对数据类型进行了大小范围限制（如int的范围时-2^31到2^31-1），而有的时候我们要计算的部分超过了这些范围甚至达到了惊人的100位以上的时候，我们就要使用高精度来进行计算。</p><p>当然，在一般的比赛当中，可以采用python等自带大数的语言，或者我们也可以将高精度的模板打印下来，需要使用的时候直接誊抄即可，但是一定要对过程有一定的理解。</p><h2 id="题目0-乒乓球"><a href="#题目0-乒乓球" class="headerlink" title="题目0: 乒乓球"></a>题目0: 乒乓球</h2><p>按照题目条件模拟即可，但是需要注意以下的情况：</p><ol><li>胜利的条件是一方优先达到11分且双方差值大于等于2，否则应当继续，且由于存在差值大于2，因此无法使用取模来进行归0；</li><li>由于分部分输出，因此需要先把后续的存起来，而前面的直接输出即可；</li><li>题目中的描述“其中EE表示比赛信息结束，程序应该忽略E之后的所有内容。”说明E可能在文件中间，切勿使用EOF判断；</li><li>由于使用的是getchar()，因此还需要额外判断我们的换行符。</li></ol><pre><code>#pragma warning(disable:4996)#include&lt;stdio.h&gt;#include&lt;math.h&gt;int ans_21[3000][2];int main() {    freopen("a.in", "r", stdin);    freopen("a.out", "w", stdout);    char temp;    int w_11 = 0, l_11 = 0, w_21 = 0, l_21 = 0, pos = 0;    temp = getchar();    while (temp != 'E') {        if (temp == '\n') {            temp = getchar();            continue;        }         if (temp == 'W')  w_11++, w_21++;        else if (temp == 'L') l_11++, l_21++;        if (w_11 &gt;= 11 || l_11 &gt;= 11) {            if (abs(w_11 - l_11) &gt; 1) {                printf("%d:%d\n", w_11, l_11);                w_11 = l_11 = 0;            }        }        if (w_21 &gt;= 21 || l_21 &gt;= 21) {            if (abs(w_21 - l_21) &gt; 1) {                ans_21[pos][0] = w_21;                ans_21[pos++][1] = l_21;                w_21 = l_21 = 0;            }        }        temp = getchar();    }    printf("%d:%d\n\n", w_11, l_11);    for (int i = 0; i &lt; pos; i++)printf("%d:%d\n", ans_21[i][0], ans_21[i][1]);    printf("%d:%d\n", w_21, l_21);    return 0;}</code></pre><h2 id="题目1-扫雷"><a href="#题目1-扫雷" class="headerlink" title="题目1: 扫雷"></a>题目1: 扫雷</h2><p>这也是一到模拟题，只需要按照其所给的方法直接计算就行了，但是我们从这道题可以学习到如何进行方向的移动和边界的处理，详见代码。</p><pre><code>#include&lt;stdio.h&gt;char map[105][105];int dx[8] = { 1,1,0,-1,-1,-1,0,1 };int dy[8] = { 0,1,1,1,0,-1,-1,-1 };int main() {    int n, m;    scanf("%d%d", &amp;n, &amp;m);    getchar();    for (int i = 1; i &lt;= n + 1; i++)        for (int j = 1; j &lt;= m + 1; j++)            map[i][j] = getchar();    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            int cnt = 0;            if (map[i][j] == '?') {                for (int k = 0; k &lt; 8; k++) {                    int temp_x = i + dx[k], temp_y = j + dy[k];                    if (temp_x &gt;= 1 &amp;&amp; temp_x &lt;= n &amp;&amp; temp_y &gt;= 1 &amp;&amp; temp_y &lt;= m)                        if (map[temp_x][temp_y] == '*') cnt++;                }            }            if (map[i][j] == '?') map[i][j] = cnt + '0';        }    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++)            printf("%c", map[i][j]);        printf("\n");    }    return 0;}</code></pre><h2 id="题目2-玩具谜题"><a href="#题目2-玩具谜题" class="headerlink" title="题目2: 玩具谜题"></a>题目2: 玩具谜题</h2><p>读入数据然后按照其要求来进行游戏就行了，这里由于是一个循环（或者一个圈），所以采用取模来进行模拟n-1到0的过程。</p><pre><code>#include&lt;stdio.h&gt;#define MAXN 100050typedef struct node{    int head;    char name[100];}node;node memo[MAXN];int main(){    int n, m, x, y;    scanf("%d%d",&amp;n,&amp;m);    for (int i = 0; i &lt; n; i++) {        scanf("%d", &amp;memo[i].head);        scanf(" %s", memo[i].name);    }    int now = 0;    for (int i = 1; i &lt;= m; i++){        scanf("%d%d", &amp;x, &amp;y);        if (memo[now].head == 0 &amp;&amp; x == 0) now = (now + n - y) % n;        else if (memo[now].head == 0 &amp;&amp; x == 1) now = (now + y) % n;        else if (memo[now].head == 1 &amp;&amp; x == 0) now = (now + y) % n;        else if (memo[now].head == 1 &amp;&amp; x == 1) now = (now + n - y) % n;    }    printf("%s", memo[now].name);    return 0;}</code></pre><h2 id="题目3和题目4：A-B-A-B"><a href="#题目3和题目4：A-B-A-B" class="headerlink" title="题目3和题目4：A+B,A*B"></a>题目3和题目4：A+B,A*B</h2><p>这两道题这里略过，洛谷的题解有很多的相关模板建议各位直接CV并添加到自己的模板当中。</p><h2 id="题目5：阶乘之和"><a href="#题目5：阶乘之和" class="headerlink" title="题目5：阶乘之和"></a>题目5：阶乘之和</h2><p>略过，前面循环那一节有。</p><h2 id="题目6：魔法少女小Scarlet"><a href="#题目6：魔法少女小Scarlet" class="headerlink" title="题目6：魔法少女小Scarlet"></a>题目6：魔法少女小Scarlet</h2><p>就是矩阵的某一个“环”的旋转问题，首先就是要生成这个举证，然后重点是需要中间额外加一个数组来保存原始矩阵，同时需要构造从原来的地图到中间数组的映射，然后再从中间数组到期望数组的映射。<br>当然你也可以只使用一个中间变量，然后通过2r+1为循环界限，然后直接一次性旋转四个元素，这样可以节省很大一部分空间。</p><pre><code>#pragma warning(disable:4996)#include&lt;stdio.h&gt;int map[505][505], media[505][505];int main() {    freopen("a.in", "r", stdin);    freopen("a.out", "w", stdout);    int m, n, x, y, z, r;    scanf("%d%d", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++) map[i][j] = (i - 1) * n + j;    for (int i = 1; i &lt;= m; i++) {        scanf("%d%d%d%d", &amp;x, &amp;y, &amp;r, &amp;z);        int begin_x = x - r, begin_y = y - r, temp_r = 2 * r + 1;        if (z) {            for (int i = 1; i &lt;= temp_r; i++)                for (int j = 1; j &lt;= temp_r; j++) media[i][j] = map[begin_x + i - 1][begin_y + j - 1];            for (int i = 1; i &lt;= temp_r; i++)                for (int j = 1; j &lt;= temp_r; j++) map[i + begin_x - 1][j + begin_y - 1] = media[j][temp_r - i + 1];        }        else {            for (int i = 1; i &lt;= temp_r; i++)                for (int j = 1; j &lt;= temp_r; j++) media[i][j] = map[begin_x + i - 1][begin_y + j - 1];            for (int i = 1; i &lt;= temp_r; i++)                for (int j = 1; j &lt;= temp_r; j++) map[i + begin_x - 1][j + begin_y - 1] = media[temp_r - j + 1][i];        }    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= n; j++) printf("%d ", map[i][j]);        printf("\n");    }    return 0;}</code></pre><h2 id="题目7：生活大爆炸版石头剪刀布"><a href="#题目7：生活大爆炸版石头剪刀布" class="headerlink" title="题目7：生活大爆炸版石头剪刀布"></a>题目7：生活大爆炸版石头剪刀布</h2><p>简单的石头剪刀布题，提前打表，且由于是规律出拳，因此需要采用取模来模拟这个循环。</p><pre><code>#include&lt;cstdio&gt;int ans[5][5] = { {0,0,1,1,0},{1,0,0,1,0},{0,1,0,0,1},{0,0,1,0,1},{1,1,0,0,0} };int memoa[250];int memob[250];int main() {    int N, NA, NB;    int Aans = 0, Bans = 0;    scanf("%d%d%d", &amp;N, &amp;NA, &amp;NB);    for (int i = 0; i &lt; NA; i++) scanf("%d", &amp;memoa[i]);    for (int i = 0; i &lt; NB; i++) scanf("%d", &amp;memob[i]);    for (int i = 0; i &lt; N; i++) {        Aans += ans[memoa[i % NA]][memob[i % NB]];        Bans += ans[memob[i % NB]][memoa[i % NA]];    }    printf("%d %d", Aans, Bans);    return 0;}</code></pre><h2 id="题目8：两只塔姆沃斯牛"><a href="#题目8：两只塔姆沃斯牛" class="headerlink" title="题目8：两只塔姆沃斯牛"></a>题目8：两只塔姆沃斯牛</h2><p>采用beacon_cwk大佬的特征值做法，若存在两次特征值相同，则说明存在某个循环导致他们永远不可能相遇，代码如下。</p><pre><code>#pragma warning(disable:4996)#include&lt;stdio.h&gt;bool eigen_value[200000];char map[15][15];int dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };bool farmercheck(int farmer_x, int farmer_y, int farmer_state) {    return farmer_x + dx[farmer_state] &lt; 0 || farmer_x + dx[farmer_state] &gt;= 10 || farmer_y + dy[farmer_state] &lt; 0 || farmer_y + dy[farmer_state] &gt;= 10 || map[farmer_x + dx[farmer_state]][farmer_y + dy[farmer_state]] == '*';}bool cowcheck(int cow_x, int cow_y, int cow_state) {    return cow_x + dx[cow_state] &lt; 0 || cow_x + dx[cow_state] &gt;= 10 || cow_y + dy[cow_state] &lt; 0 || cow_y + dy[cow_state] &gt;= 10 || map[cow_x + dx[cow_state]][cow_y + dy[cow_state]] == '*';}int main(){    freopen("a.in", "r", stdin);    freopen("a.out", "w", stdout);    int cow_x, cow_y, cow_state = 0, farmer_x, farmer_y, farmer_state = 0, now_eigen, step = 0;    for (int i = 0; i &lt; 10; i++) scanf("%s", map[i]);    for (int i = 0; i &lt; 10; i++)        for (int j = 0; j &lt; 10; j++){            if (map[i][j] == 'F') farmer_x = i, farmer_y = j;            if (map[i][j] == 'C') cow_x = i, cow_y = j;        }    while (1){        if (farmer_x == cow_x &amp;&amp; farmer_y == cow_y)            return 0 * printf("%d", step);        now_eigen = farmer_x + farmer_y * 10 + cow_x * 100 + cow_y * 1000 + farmer_state * 10000 + cow_state * 40000;        if (eigen_value[now_eigen]) return 0 * printf("0");        eigen_value[now_eigen] = true;        if (farmercheck(farmer_x, farmer_y, farmer_state))            farmer_state = (farmer_state + 1) % 4;        else farmer_x = farmer_x + dx[farmer_state], farmer_y = farmer_y + dy[farmer_state];        if (cowcheck(cow_x, cow_y, cow_state))            cow_state = (cow_state + 1) % 4;        else cow_x = cow_x + dx[cow_state], cow_y = cow_y + dy[cow_state];        step++;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 高精度 </category>
          
          <category> 模拟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法题解 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷官方提单——函数与结构入门题解（水题警告）</title>
      <link href="/2020/04/16/luo-gu-guan-fang-ti-dan-han-shu-yu-yu-jie-gou-ru-men-ti-jie-bu-fen-shui-ti-jing-gao/"/>
      <url>/2020/04/16/luo-gu-guan-fang-ti-dan-han-shu-yu-yu-jie-gou-ru-men-ti-jie-bu-fen-shui-ti-jing-gao/</url>
      
        <content type="html"><![CDATA[<p>函数实际上就是我们将程序的语句分成不同的块，每一块都执行不同的操作，这样的“代码块”称之为函数(function)。通过将代码分割为一个又一个的函数，虽然在执行函数调用的时候存在开销，但是在后续对程序的修改和对功能的扩充比直接在main函数中方便得多。<br>顺带一提，在C++中，最好将接口写在main函数上面，这样就可以减少一行前置声明（具体相关请翻看相关书籍查找前置声明）。<br>结构体则是数据的集合，从数组，到链表，再到OS里的PCB，这些很多都是结构体。每个结构体由程序员自行设计，通过将数据“打包”，可以在进行某些操作（比如排序）会更加的方便。</p><p>接下来就是关于本题单的题解了。</p><h2 id="题目0-距离函数"><a href="#题目0-距离函数" class="headerlink" title="题目0:  距离函数"></a>题目0:  距离函数</h2><p>就是简单的两点之间的距离公式的计算机实现，注意输出格式和数据类型就很简单了。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;double dist(double x1,double x2,double y1,double y2){    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}int main(){    double x1,y1,x2,y2,x3,y3;    scanf("%lf%lf%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3);    double ans=dist(x1,x2,y1,y2)+dist(x1,x3,y1,y3)+dist(x2,x3,y2,y3);    return 0*printf("%.2lf\n",ans);}</code></pre><h2 id="题目1：质数筛"><a href="#题目1：质数筛" class="headerlink" title="题目1：质数筛"></a>题目1：质数筛</h2><p>模板题，筛选方法有欧拉筛或者埃筛，一般题目中埃筛就够了，碰到了欧拉筛再补充吧。<br>埃筛的过程是：开一个数组vis，0和1标记为“不是素数”的flag，然后从2开始遍历，如果vis[i]是质数，那么从这个质数开始的2倍，3倍直至最后边界范围内都不会质数，提前标记为“不是质数”；若“不是质数”，则直接进入下一轮循环，这样我们在调用是不是质数的时候，只需要简单的判断vis[num]的标记即可。</p><pre><code>#include&lt;stdio.h&gt;bool numlist[100050] = { 1,1 };void work() {    for (int i = 2; i &lt;= 10000; i++) {        if (numlist[i] == false) {            for (int j = i; i * j &lt;= 100000; j++)                numlist[i * j] = true;        }    }    return;}int main() {    int n, temp;    scanf("%d", &amp;n);    work();    for (int i = 0; i &lt; n; i++) {        scanf("%d", &amp;temp);        if (numlist[temp] == false)            printf("%d ", temp);    }    return 0;}</code></pre><h2 id="题目2：闰年展示"><a href="#题目2：闰年展示" class="headerlink" title="题目2：闰年展示"></a>题目2：闰年展示</h2><p>判断闰年在题单1就有了，主要是在输出年之前需要count，因此需要存下来。</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;int main() {    int x, y, cnt = 0;    std::vector&lt;int&gt; ans;    std::cin &gt;&gt; x &gt;&gt; y;    for (int i = x; i &lt;= y; i++)        if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || (i % 400 == 0))            ans.push_back(i), cnt++;    std::cout &lt;&lt; cnt &lt;&lt; std::endl;    for (int i=0;i&lt;cnt;i++) std::cout &lt;&lt; ans[i] &lt;&lt; ' ';    return 0;}</code></pre><h2 id="题目3：歌唱比赛"><a href="#题目3：歌唱比赛" class="headerlink" title="题目3：歌唱比赛"></a>题目3：歌唱比赛</h2><p>这道题没啥讲的= =，基本就是前面的题的组合。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int memo[25];double max(double x, double y) { return x &gt; y ? x : y; }int main() {    int n, m;    double mmax = -1;    scanf("%d%d", &amp;n, &amp;m);    while (n--) {        double sum = 0.0;        for (int i = 0; i &lt; m; i++)            scanf("%d", &amp;memo[i]);        std::sort(memo, memo + m);        for (int i = 1; i &lt; m - 1; i++) sum += memo[i];        mmax = max(mmax, sum / (m - 2));    }    return 0 * printf("%.2lf", mmax);}</code></pre><h2 id="题目4：阶乘"><a href="#题目4：阶乘" class="headerlink" title="题目4：阶乘"></a>题目4：阶乘</h2><p>直接递归即可。(当n很大的时候建议使用之前写过的杨辉三角）</p><pre><code>#include&lt;stdio.h&gt;int jie(int x) {    if (x == 0) return 1;    else return x * jie(x - 1);}int main() {    int n;    scanf("%d", &amp;n);    int ans = jie(n);    printf("%d", ans);    return 0;}</code></pre><h2 id="题目5：赦免战俘"><a href="#题目5：赦免战俘" class="headerlink" title="题目5：赦免战俘"></a>题目5：赦免战俘</h2><p>这种带有典型的分形的题就是典型的递归题目。<br>另解，实际这道题也可以发现，ans[i][j]=ans[i][j-1]^ans[i+1][j-1]，这类题都会存在类似的规律，一般来说如果sample给的十分遮掩可以考虑试试这种方法来“凑”答案。</p><pre><code>#include&lt;stdio.h&gt;int n, ans[1050][1050];void work(int n, int x, int y){    if (n == 2){        ans[x][y] = 0;        return;    }    for (int i = x; i &lt;= x + n / 2 - 1; i++)        for (int j = y; j &lt;= y + n / 2 - 1; j++) ans[i][j] = 0;     work(n / 2, x + n / 2, y);    work(n / 2, x + n / 2, y + n / 2);    work(n / 2, x, y + n / 2); }int main(){    scanf("%d", &amp;n);    for (int i = 1; i &lt;= 1&lt;&lt;n; i++)        for (int j = 1; j &lt;= 1 &lt;&lt; n; j++) ans[i][j] = 1;    work(1 &lt;&lt; n, 1, 1);    for (int i = 1; i &lt;= 1 &lt;&lt; n; i++) {        for (int j = 1; j &lt;= 1 &lt;&lt; n; j++)            printf("%d ", ans[i][j]);        printf("\n");    }    return 0;}</code></pre><h2 id="题目6：最厉害的学生"><a href="#题目6：最厉害的学生" class="headerlink" title="题目6：最厉害的学生"></a>题目6：最厉害的学生</h2><p>大家都应该知道在algorithm库里面有个sort函数，按照一般的升序我们只需要sort(s.begin(),s.end())，但是我们可以通过使用第三个可选参数来决定比较方式，通过写一个函数接口即可解决。</p><pre><code>//比赛的时候没必要这么命名#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct hello {    int Chinese, Math, English;    string Name;}student[1000];bool cmp(hello student1, hello student2) {     return student1.Chinese + student1.Math + student1.English &gt; student2.Chinese + student2.Math + student2.English; }int main(){    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)        cin &gt;&gt; student[i].Name &gt;&gt; student[i].Chinese &gt;&gt; student[i].Math &gt;&gt; student[i].English;    sort(student, student + n, cmp);    cout &lt;&lt; student[0].Name &lt;&lt; " " &lt;&lt; student[0].Chinese &lt;&lt; " " &lt;&lt; student[0].Math &lt;&lt; " " &lt;&lt; student[0].English &lt;&lt; endl;    return 0;}</code></pre><h2 id="题目7：旗鼓相当的对手-加强版"><a href="#题目7：旗鼓相当的对手-加强版" class="headerlink" title="题目7：旗鼓相当的对手 - 加强版"></a>题目7：旗鼓相当的对手 - 加强版</h2><p>也就是判断条件比较复杂，实际上还是很简单，但是注意总分的时候不要把之前算的三个差值直接加起来。</p><pre><code>#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct S {    string Name;    int Chinese, Math, English;}student[1024];int main() {    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)          cin &gt;&gt; student[i].Name &gt;&gt; student[i].Chinese &gt;&gt; student[i].Math &gt;&gt; student[i].English;    for (int i = 0; i &lt; n; i++) {        for (int j = i + 1; j &lt; n; j++) {            int sub1 = abs(student[i].Chinese - student[j].Chinese);            int sub2 = abs(student[i].Math - student[j].Math);            int sub3 = abs(student[i].English - student[j].English);            int sub4 = abs(student[i].English + student[i].Chinese + student[i].Math - student[j].Chinese - student[j].Math - student[j].English);            if (sub1 &lt;= 5 &amp;&amp; sub2 &lt;= 5 &amp;&amp; sub3 &lt;= 5 &amp;&amp; sub4 &lt;= 10) {                if (student[i].Name &gt; student[j].Name) cout &lt;&lt; student[j].Name &lt;&lt; " " &lt;&lt; student[i].Name &lt;&lt; endl;                else cout &lt;&lt; student[i].Name &lt;&lt; " " &lt;&lt; student[j].Name &lt;&lt; endl;            }        }    }    return 0;}</code></pre><h2 id="题目8：评级"><a href="#题目8：评级" class="headerlink" title="题目8：评级"></a>题目8：评级</h2><p>emmm经过题目8，这道题就没必要讲了吧。</p><pre><code>#include&lt;iostream&gt;using namespace std;struct student {    int student_number, study_grade, other_grade;}st[1010];int main() {    int n;    double after_weight = 0;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++) {        cin &gt;&gt; st[i].student_number &gt;&gt; st[i].study_grade &gt;&gt; st[i].other_grade;        after_weight = st[i].study_grade * 0.7 + st[i].other_grade * 0.3;        if (after_weight &gt; 80 &amp;&amp; st[i].study_grade + st[i].other_grade &gt; 140) cout &lt;&lt; "Excellent" &lt;&lt; endl;        else cout &lt;&lt; "Not excellent" &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="题目9：质因数分解"><a href="#题目9：质因数分解" class="headerlink" title="题目9：质因数分解"></a>题目9：质因数分解</h2><p>循环结构的原题，自己回去看。</p><h2 id="题目10：哥德巴赫猜想"><a href="#题目10：哥德巴赫猜想" class="headerlink" title="题目10：哥德巴赫猜想"></a>题目10：哥德巴赫猜想</h2><p>因为要分解为质数之和，所以我们直接把质数先筛选出来（没错就是前面的质数筛），然后从小到大直接加就ok了。</p><pre><code>#include &lt;stdio.h&gt;int prime[10000] = { 1,1 }, n;void filter() {    for (int j = 2; j &lt; 10000; j++)        for (int k = j * 2; k &lt; 10000; k += j) prime[k] = 1;}int main() {    scanf("%d", &amp;n);    filter();    for (int i = 4; i &lt;= n; i += 2) {        int j = 2;//这里要注意，一定每次进第一循环的时候初始化为2        for (; prime[j] || prime[i - j]; j++);        printf("%d=%d+%d\n", i, j, i - j);    }    return 0;}</code></pre><h2 id="题目11：集合求和"><a href="#题目11：集合求和" class="headerlink" title="题目11：集合求和"></a>题目11：集合求和</h2><p>这里大致说一下推理过程，首先我们知道对于每一个有n个元素的集合，其子集个数为2^n。<br>当子集只有一个元素的时候，每个元素被选中一次；当子集中只有两个元素的时候，恰好被选中C(n,2）次，依次类推，只需要对n对于1到n的所有组合数求和再乘以所有元素的和即为答案（这里涉及到二项式定理）。</p><pre><code>#include &lt;stdio.h&gt;int main() {    long long ans = 0;    int cnt = 0, temp;    while (~scanf("%d", &amp;temp)) ans += temp, cnt++;    for (int i = 1; i &lt; cnt; i++) ans *= 2;    printf("%lld", ans);    return 0;}</code></pre><h2 id="题目12：回文质数"><a href="#题目12：回文质数" class="headerlink" title="题目12：回文质数"></a>题目12：回文质数</h2><p>原题略。</p><h2 id="题目13：猴子吃桃"><a href="#题目13：猴子吃桃" class="headerlink" title="题目13：猴子吃桃"></a>题目13：猴子吃桃</h2><p>纯模拟，会读题小学生都会。</p><pre><code>#include&lt;iostream&gt;using namespace std;int main() {    int n, ans = 1;    cin &gt;&gt; n;    for (int i = 1; i &lt; n; i++)         ans = (ans + 1) * 2;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h2 id="题目14：培训"><a href="#题目14：培训" class="headerlink" title="题目14：培训"></a>题目14：培训</h2><p>和上面那些比较分数的大同小异、</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student {    string name;    int age, score;} candidate[100000];int main() {    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++) {        cin &gt;&gt; candidate[i].name &gt;&gt; candidate[i].age &gt;&gt; candidate[i].score;        candidate[i].age++, candidate[i].score = candidate[i].score / 5 * 6;        if (candidate[i].score &gt; 600) candidate[i].score = 600;        cout &lt;&lt; candidate[i].name &lt;&lt; " " &lt;&lt; candidate[i].age &lt;&lt; " " &lt;&lt; candidate[i].score &lt;&lt; endl;    }    return 0;}</code></pre><p>入门题刷完了，明天就要开始六大基础算法的刷题，争取一天两个吧（bushi）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法题解 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学知识点整整理（施工未完成）（一）</title>
      <link href="/2020/04/15/ji-suan-ji-tu-xing-xue-zhi-shi-dian-zheng-zheng-li-yi/"/>
      <url>/2020/04/15/ji-suan-ji-tu-xing-xue-zhi-shi-dian-zheng-zheng-li-yi/</url>
      
        <content type="html"><![CDATA[<p>这个部分是在寒假学习图形学过程中自己整理的图形学知识，后续会进行精简和删改，也方便自己后续查找概念。</p><h2 id="图形学的基本目标"><a href="#图形学的基本目标" class="headerlink" title="图形学的基本目标"></a>图形学的基本目标</h2><p>从虚拟的三位场景以及相机的位置信息中生成二维图像——简单图形直接使用参数描述，而复杂模型需要使用参数曲线和曲面或者更一般的网格模型，而网格模型中又以三角网格最为常用。</p><h2 id="1-色彩模型（Color-Model）"><a href="#1-色彩模型（Color-Model）" class="headerlink" title="1. 色彩模型（Color Model）"></a>1. 色彩模型（Color Model）</h2><h3 id="1-1-色彩视觉"><a href="#1-1-色彩视觉" class="headerlink" title="1.1 色彩视觉"></a>1.1 色彩视觉</h3><p>(1). 色彩：对不同波长的光的能量感知：不同波长对于不同颜色，人可见光为380-760nm之间；</p><p>(2). 光的谱分布：光在各个可见波长的分量的强度分布函数称为光的谱分布函数。与光类似，色彩也可以使用谱分布函数描述，但是由于异谱同色现象，导致描述方法特别复杂且不能一一对应；</p><p>(3). 色彩颜色空间：在所有用于表示色彩的各种颜色空间，以RGB色彩空间最为广泛(存疑)：1. 色彩使用三通道的RGB向量表示；2. 在RGB色彩空间中，有部分的常用操作可以通过对RGB三通道分别处理而进行；3. r,g,b可以用规格化的的float；而使用8bit存储时，取值为[0,255]；4. 色彩被表示为三个基本颜色的线性组合：C=rR+gG+bB。但是可能会有部分的颜色无法表示为正线性组合，(0,0,0)为黑，(1,1,1)为白；</p><p>(4). 其他的颜色空间：<br>a. CMY：青+品红+黄(注意这里和印刷所用的CMYK不一样，K为黑色，这里是颜色空间而不是印刷色彩模式)。其为减色系统，[C,M,T]=[1,1,1]-[R,G,B]，即CMY分别为R,G,B的补色(和补码差不多)，(0,0,0)为白，(1,1,1)为黑；<br>b. HSV：其为圆锥形的色彩空间，Hue色调/色相——根据颜色来，Saturation饱和度/纯度——越低越白，Value of brightness亮度——越低越黑；<br>c. CIE XYZ(1931)：可以感知所有的色彩，色彩基XYZ是色彩基RGB的线性变换。x=X/(X+Y+Z);y=Y/(X+Y+Z)，z=1-x-y。</p><h3 id="1-2-图像和像素"><a href="#1-2-图像和像素" class="headerlink" title="1.2 图像和像素"></a>1.2 图像和像素</h3><p>图像是指的二维离散函数f(x,y)，f的定义域为矩阵中的所有格子，这些格子称之为像素，其值为各个像素的色彩，彩色图像可为RGB(A)，而灰度图像f则为单值。</p><h3 id="补充：三角网格（Mesh）"><a href="#补充：三角网格（Mesh）" class="headerlink" title="补充：三角网格（Mesh）"></a>补充：三角网格（Mesh）</h3><p>在一系列欧式空间中的三位顶点以及连接这些顶点的若干三角面片组成，顶点集合记为V，而面片集合记为F，而F中的每个fi为V中的vai，vbi，vci顶点构成的空间三角形。重点为计算法向量（normal）（定义略，有两种朝向，决定正反面，朝外为+，朝外为-），对于连续可定向的额三角网格整体而言，相邻三角面片需要具备一致的法向量朝向；通过三角网格周围的所有三角面片的法向量加权叠加计算（算数平均，面积加权，角度加权等）。简单绘制方法：每个顶点指定一个色彩属性；基于色彩绘制——模型表面的每点的色彩通过其所在三角面片的顶点色彩插值得到（插值可以用来使模型变得更光滑）；基于光照绘制——需要指定一个虚拟的光照环境，重点问题是计算光照对色彩的影响。</p><h2 id="2-光照模型（illumination-model）"><a href="#2-光照模型（illumination-model）" class="headerlink" title="2. 光照模型（illumination model）"></a>2. 光照模型（illumination model）</h2><p>光照模型用于计算光的强度：局部光照明——物体直接受到光源影响产生的光照效果和全局光照明——阴影效果和所有不是直接与光源位置相关的光照效果（反射折射等）。</p><h3 id="2-1历史："><a href="#2-1历史：" class="headerlink" title="2.1历史："></a>2.1历史：</h3><p>在渲染中加入光照明效果——光强与物体到光源距离成反比（1967） —&gt;第一个光反射模型——Lambert漫反射光+环境光（1970）—&gt;漫反射模型+插值的思想（Lambert diffuse + Bicentric interpolation）（1971）—&gt;Phong模型——Diffuse（漫发射）+ ambient（环境光）+ specular（高光）（顶点法向插值）。</p><h3 id="2-2-光的传播定律"><a href="#2-2-光的传播定律" class="headerlink" title="2.2 光的传播定律"></a>2.2 光的传播定律</h3><p>反射定律——入射角=反射角，入射光线、反射光线，反射面的法向量位于同一平面；折射定律：sin入射角：sin折射角=常数（相对折射系数，记为n折/n入）；能量守恒定律Ii=Id+Is+It+Iv（依次为入射光，漫反射光—diffuse，镜面反射光—specular，折射光—refraction，介质和物体吸收的能量）。</p><h3 id="2-3-光的度量"><a href="#2-3-光的度量" class="headerlink" title="2.3 光的度量"></a>2.3 光的度量</h3><p>立体角——衡量物体相对于某一视点P的视角大小，最大为4π；光通量（辉度）——单位时间间内通过面元dS的光能量，记为dF（或E）；发光强度——单位立体角内的光通量，记为I。</p><h3 id="2-4-Phong模型"><a href="#2-4-Phong模型" class="headerlink" title="2.4 Phong模型"></a>2.4 Phong模型</h3><p>支持点光源和方向光源，是局部光照模型分解为漫反射光，镜面光和环境光效果（相关字母含义见图：待补充）。<br>L是入射光，R是反射光，V是视点方向，N为物体表面的法向量，H是L和V夹角的角平分线；<br>漫反射光效果：（公式），其中Kd是漫反射系数，分别由kdr，kdg，kdb代表R，G，B三个通道的漫反射系数，其与模型自身的色彩紧密相关；<br>镜面光效果：Is=IiKs<em>(RV)n，Ks是镜面反射系数，与物体表面的光滑程度相关，n是反射指数，n越大，高光区越集中；<br>环境光效果Ia=IiKa，Ka是物体对环境光的反射系数；<br>视角方向的发光强度为漫反射光分量、镜面反射光分量和环境反射光分量之和即：I= IiKd</em>(LN)+ IiKs*(RV)n+ IiKa。</p><h2 id="3-明暗处理（Shading）"><a href="#3-明暗处理（Shading）" class="headerlink" title="3 明暗处理（Shading）"></a>3 明暗处理（Shading）</h2><h3 id="3-1-插值的理由和插值方法"><a href="#3-1-插值的理由和插值方法" class="headerlink" title="3.1 插值的理由和插值方法"></a>3.1 插值的理由和插值方法</h3><p>由于物体表面的集合细节往往不规则，为了减缓由模型离散化导致的不光滑的色彩效果，会导致Mach Band效应（产生明亮或黑暗的条纹）。通常需要除了使用光照模型外，还需要插值。一般的处理方式为Gouraud shading——对色彩插值和Phong shading——对法相进行插值。<br>(1). Gouraud shading：计算所有模型顶点的色彩值对任意一点，按照三角面片上顶点的色彩值按重心（Barycentric Interpolation）结果赋值；<br>(2). Phong shading：对点的法向量进行插值，得到连续的法向量场，再利用该法向量场逐点使用光照模型进行色彩计算。</p><h3 id="3-2-视点变换和视点方向"><a href="#3-2-视点变换和视点方向" class="headerlink" title="3.2 视点变换和视点方向"></a>3.2 视点变换和视点方向</h3><p>由几何模型组成的三位场景绘制成高质量的彩色图——通过变换（将空间中的点x映射为点x’的函数）。通过变换，可以设置和编辑3D场景光照位置和视点方向（camera）变换有简单变换（不变，平移，旋转，均衡缩放），常见变换（刚体——保持物质本身的度量，相似——保持角度，线性——保持线性关系l+p，kl的变换，仿射——保持直线即相互平行的直线，投影）。变换的表示，M和t（详见高代）：p’=Mp+t（M为二维），若使用齐次坐标（使用n+1维数组来表示n维空间中的点和向量）时，则p’=Mp（M为三维），具体略（注意Rodrigues公式）。复合变换一般不能交换顺序。在法向量（与曲面正交的单位向量）交换中，我们要通过变换切平面，再计算法向量。vOS变换为vWS则vWS=MvOS，转换为切平面后为vWS=（M-1）TvOS，即法向量的变换矩阵是原变换矩阵的逆和转置。</p><h3 id="3-3-视点和投影模式"><a href="#3-3-视点和投影模式" class="headerlink" title="3.3 视点和投影模式."></a>3.3 视点和投影模式.</h3><p>在投影中<br>(1). 视点变换与camera位置及朝向有关；<br>(2). 投影模式，3D变换为2D，常用正交投影（直接把第三维变0）和透视投影（使用透视投影矩阵）。</p><h2 id="4-材质反射属性模型——双向反射分布函数（BRDF：Bidirectional-Reflectance-Distribution-Function）"><a href="#4-材质反射属性模型——双向反射分布函数（BRDF：Bidirectional-Reflectance-Distribution-Function）" class="headerlink" title="4. 材质反射属性模型——双向反射分布函数（BRDF：Bidirectional Reflectance Distribution Function）"></a>4. 材质反射属性模型——双向反射分布函数（BRDF：Bidirectional Reflectance Distribution Function）</h2><p>BRDF是描述物体表面对光的反射性质。</p><h3 id="4-1-基础知识"><a href="#4-1-基础知识" class="headerlink" title="4.1 基础知识"></a>4.1 基础知识</h3><p>(1). 光照/照明（illumination）：分为局部光照和全局光照（见1.2）；<br>(2). 球面坐标：空间中一个点由向量长度，向量和z轴的夹角，向量在xy面上的投影和x轴的逆时针夹角（极坐标升维）；<br>(3). 立体角：是一个物体对特定点的三维空间的角度，是平面角在三维空间中的类比。它描述的是站在某一点的观察者测量到的物体大小的尺度；<br>(4). 投影面积：字面意思；<br>(5). 光能（光子能量总和），光通量（和磁通量类似）；<br>(6). 辉度E（见P1）：单位面积上的光通量；<br>(7). 光强：单位立体角的光通量；<br>(8). 光亮度：单位投影面积和单位立体角上的光通量（ps辉度和光亮度的数学关系：待补充）。</p><h3 id="4-2-BRDF"><a href="#4-2-BRDF" class="headerlink" title="4.2 BRDF"></a>4.2 BRDF</h3><p>(1). 定义：描述物体表面将光能从任意入射方向反射到任意视点方向的反射特性，是关于入射光方向和反射光方向的四维实函数，其等于反射方向的光亮度和沿入射方向的入射光辉度之比（或入射光的光亮度）；<br>(2). 性质：<br>a. 可逆性（由于光路可逆）；<br>b. 能量守恒；<br>c. 渲染方程（用于计算环境光照明下的反射光光亮度，可写为下述样式的积分（公式略））</p><p>(3). 模型：经验模型，基于物理表达，基于数据表达模型：<br>a. 经验模型中，Lambertain漫反射模型是最基本的反射模型——入射光线被均匀地反射到各个方向，不同方向的BRDF是一个常数。反射率是反射光的辉度和入射光的辉度之比。Phong模型，在Lambert漫反射模型基础上，添加了镜面反射项，以表达镜面反射效果，但是其不具备可逆性，不准确但是简洁高效。Blinn-Phong模型，引入入射方向和反射方向的角平分线h，使用h和法向量n的点积替代原Phong中r和v的点积，以简化运算；</p><p>b. 物理模型中，建立在表面粗糙度的细节几何结构上，通过微平面法向量的统计分布表达；同时在实际应用中，单向反射性存在擦地角附近增大的性质，且入射光的反射光是由麦克斯韦方程组中得到的菲涅尔公式（Fresnel）得到，内容略。Cook-Torrance模型，假设微平面为镜面反射，且假定为V，然后结合Lambertian漫反射项与微平面项结合同时采区Bechmannn分布来描述微平面法向的分布函数；</p><p>c. 数据模型：暂时没有过多的了解。</p><p>(4). BRDF的度量和评价。<br>动机是为了对未知反射属性的材料进行建模，并生产具有高度真实感的结果，恢复BRDF和其他场景属性的过程称之为逆渲染（inverse rendering）。<br>BRDF的度量和评价：a.度量设备——由于BRDF是关于光线和视角的函数，其度量通过对2D光照空间和2D视角空间进行采样获取。故需要sample，source和detector，固定材料或光源或材料（用于已知凸几何体）和光源而移动其他的方式，e.g light stage。</p><h2 id="5-光线追踪"><a href="#5-光线追踪" class="headerlink" title="5. 光线追踪"></a>5. 光线追踪</h2><p>思路和框架：将显示缓存区看成是由空间中的像素组成的矩阵阵列，人眼透过这些像素看到场景中的物体。对于每个像素P计算其色彩值：计算视点链接像素P中心的光线演唱后所碰到的第一个物体交点，然后使用局部光照模型计算交点处的颜色值，然后沿交点处的反射和折射方向队光线进行跟踪。通过光线跟踪，可以很容易的表现出阴影反射折射之类的视觉效果，且更容易适用于复杂的物体表示方法。</p><h3 id="5-1-光线求交（后续修改）"><a href="#5-1-光线求交（后续修改）" class="headerlink" title="5.1 光线求交（后续修改）"></a>5.1 光线求交（后续修改）</h3><p>(1). 光线的表示：</p><p>(2). 平面的表示：</p><p>(3). 点到平面的距离：</p><p>(4) 光线和平面求交：</p><p>(5). 光线和三角形求交：</p><p>(6) 光线和多边形求交： </p><p>(7)．光线和球面相交的球面的表示：</p><h2 id="6-光线追踪加速"><a href="#6-光线追踪加速" class="headerlink" title="6.光线追踪加速"></a>6.光线追踪加速</h2><p>原因：时空复杂度高，主要消耗在于可见性判断和求交测；<br>方法：空间数据结构，比如层次包围体，均匀格点，四叉树八叉树空间二分树。</p><h3 id="6-1-光线求交："><a href="#6-1-光线求交：" class="headerlink" title="6.1 光线求交："></a>6.1 光线求交：</h3><p>(1). 包围盒（比如把一个兔子包到一个长方体里）（多重包围方法比如平行于坐标轴，非平行与坐标盒，OBB）：除非交于长方体，否则不会与兔子相交；后续由Kay和Kajiya 提出，根据景物的实际形状选取n组不同方向的平行平面包裹一个景物或者一组景物来做为层次包围盒——定义一任意平面方程Ax+By+Cz-d=0，则可以得到一个法向量N，且与原点距离为d的平面，令d为自由向量，则定义了一组平面（流形？），故对于任意给定景物，必然存在两平面将景物夹在中间，记为d_i^near 和d_i^far，用几组平面可以构成一个紧致包围盒，取若干统一方向为平面法向，并取n小于5。而对于d_i^near 和d_i^far，显式曲面我们可以将多面体的所有顶点投影到法向量方向，并计算与原点的最大值最小值；隐式曲面体，用条件极值的极大极小值——拉格朗日乘数法。</p><p>(2). 包围球：一个包围球仅包含两组参数，球心和半径。物体转包围盒不转一般极度理想的包围球比较难，采用n个点的近似最优包围球（计算几何相关），一把比理想包围球大5%。方法：遍历所有点找到最大最小的x/y/z的三组六个点，然后计算三组距离，选取最大值，然后作为包围球直径，作为算法的初始值；然后遍历所有的点，若当前点在包围球外，则修改直径（以当前在球外的点与球心相连接，反向延长到之前的交点）</p><p>(3). 层次包围体：给定场景的所有物体的包围体，可以将这些包围体作为叶子节点，构建一个包围体树-HBV，每个内部节点的所有子孙节点对应的包围体并集。从根节点往下层次遍历，计有n个包围盒，则由n降维为logn。</p><p>(4). 均匀格点：存到一个三维格点整列，有相交的则记录到一个list。然后用DDDA算法类似，光线与x和y的交点成规律排布（dy/dx不变），容易建立，但物体分布可能不均匀可能会浪费因此最好为非均匀空间分布。</p><p>(5). 四叉/八叉树：四叉树为二叉树而为推广，每个节点为正方形，递归的将每个正方形分为四个等大的小正方形，叶子节点面片数足够简单时停止扫描；八叉树为四叉树的三维推广，和四叉类似，但是每个节点为立方体，且遍历更复杂，但对非均匀场景更适合。八叉树的构建：将场景用一个最小的平行于坐标轴放置的立方体包围，使用自顶向下的递归划分直到边界条件（深度，面片数之类的）前，将节点划分为八个等大的小立方体，注意到可能会有同一面片存储在不同的叶节点，可能会导致效率下降，可以采用将面片聪姐上分为多个，也可以采用Octree-R方法——通过启发式算法，更为自由的划分面片，从而提速4%-47%。节点寻址：指针或者编号（使用该节点的编号加上1到8作为其suffix）。光线的遍历，每与八叉树的一个内部节点相交，都有可能与至多四个节点相交，因此需要使用空间八叉树剖分技术。</p><p>(6). 空间八叉树剖分技术：一个空间非均匀网格剖分算法：将含有整个场景的空间立方体按三个方向中剖面分割成八个子立方体网格，组织成一棵八叉树，若某一子立方体网格中所含景物面片数大于给定的阈值，则为该子立方体作进一步的剖分，直到面片数目小于阈值；然后利用空间连贯性加速光线追踪。而八叉树的最大深度表示空间分割所能达到的层次，称为空间分配率，同时计八叉树深度为N，则编码为q1q2…qiFF…F（[0,7]的整数序列，F为不同于[0,7]的符号），则可以通过节点编码方式很容易找到任一点所在网格。同时其具备的性质：P(x,y,z)为空间一点，坐标为整数，表示为x=i1i2…inB，y=j1j2…jnB，z=k1k2…kn，i1,j1,k1∈{0,1}，l =1,2,…,N。性质1：P所在的单位立方格编码为q_l=i_l+2j_l+4k_l, l见前提。性质B：P位于一编码为q1q2…qiFF…F的空间网格内，则网格的前左下角坐标为x^’=i_1 i_2…i_i 0…0(y,z则为对应的j、k)</p><p>(7). 通过八叉树的光线跟踪加速：利用性质A求光线起点P0所在的立方网格编码Q，然后位于边界上的起点根据光线前进方向R辨别光线是否射出场景，如果射出，算法结束。其查找结果为是否匹配成功的bool以及没有匹配的位数B——若Q为q1q2…qi，则八叉树中节点含有q1q2…qiFF…F时取T，B则定义为八叉树叶节点表中与Q获得最大程度匹配的节点其编码suf不匹配的位数。T决定是否包含面片，Q和B决定立方体的空间位置和大小。若bool量为T，则光线与该立方体中所含三角形面片求交，若交返回交点，若T为F；则继续搜索，包含起点且不包含任何景物面片的最大空间网格为q1q2…qiq+1FF…F，F为B-1个；或者求交失败为假，应该跨过当前立方体网格。而新的网格前左下角坐标有性质B决定，跨越网格后，先求出当前空间网格上的出口点坐标，重置光线起点——光线和六面求交，且预先计算光线在各个坐标平面上投影线的结局和斜率，快速求解。通过新出发点重复跟踪过程，直至光线射出场景或者求到交点。</p><p>(8). 空间二叉树（BSP）：空间划分结构，起初用于解决图形学中隐藏表面为题，为二分查找树的高维推广，主要有axis-aligned类型和polygon-aligned类型。polygon-aligned BSP. 每次选取一个多边形面片所在的平面，作为空间的划分平面，通常来说，当由多边形组成才是用polygon-aligned BSP。而axis-aligned总是沿着某个坐标轴垂直方向划分平面，且划分平面总是把节点按照空间大小划分为两个相等的子节点（也有部分认为随意划分也可），其大大减少了光线和划分平面间的计算量（33%），建树过程差不多。而在过程中，我们可以根据深度进行规则轮换，这样的话是的层次结构的划分更加规则regular。</p><p>(9). KD树（任意一个BSP都是KD，但是KD不是BSP），其与BSP区别在于划分平面，KD任意，BSP二分划分。</p><p>(10). BSD的遍历：第一次调用函数时，min和max初始化为BSP根节点对应立方体的两个焦点到光线原点的距离。若光线从根节点立方体内部发出，则min为负数。BSP遍历一般比八叉快10%。由于BSP总是从终点开始划分，因此也存在面片跨越多个节点导致遍历变慢。而kd就是为了解决这个问题。<br>一下内容暂略：<br>分布式光线跟踪（随机光线跟踪）；光束追踪（线变锥形，首先将初始光束投向可视空间，由近及远监测光束与场景中物体的交，交点处产生新的反射折射光束，也可以使用光束树），具选择性的光线跟踪结合插值（选择部分，剩余插值）。RPU（可编程光线处理单元）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷官方提单——字符串入门题解（部分水题警告）</title>
      <link href="/2020/04/15/luo-gu-guan-fang-ti-dan-zi-fu-chuan-ru-men-ti-jie-bu-fen-shui-ti-jing-gao/"/>
      <url>/2020/04/15/luo-gu-guan-fang-ti-dan-zi-fu-chuan-ru-men-ti-jie-bu-fen-shui-ti-jing-gao/</url>
      
        <content type="html"><![CDATA[<p>今天是字符串的入门题，字符串的题学习建议使用cpp的stl中的string，虽然STL又名sometime time limit，但是自己使用char数组写轮子很容易产生越界导致的RTE或者SE。<br>同时希望大家能够记住string.h和string的函数，至少看名字要知道他是什么意思，这样才能极大的提高做串类型的题的速度。<br>废话不多说，直接进入正题。</p><h2 id="题目0：自动修正"><a href="#题目0：自动修正" class="headerlink" title="题目0：自动修正"></a>题目0：自动修正</h2><p>简单的大小写替换题。代码给两种</p><pre><code>//pythonprint(input().upper())//cpp头文件啥的省略嗷for(int i =0;i&lt;len;i++){    if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') printf("%c",s[i]-'a'+'A');    else printf("%c",s[i]);}</code></pre><h2 id="题目1：小书童——密码"><a href="#题目1：小书童——密码" class="headerlink" title="题目1：小书童——密码"></a>题目1：小书童——密码</h2><p>简单的对每一个字母+n即可，但是注意整个要对26取模保证始终是字母。</p><pre><code>for(int i = 0; s[i]&lt;len ; i++)     printf("%c",(s[i]-'a'+n)%26+'a')</code></pre><h2 id="题目2：笨小猴"><a href="#题目2：笨小猴" class="headerlink" title="题目2：笨小猴"></a>题目2：笨小猴</h2><p>实不相瞒，这道题我坐着我觉得我也蛮笨的（bushi）,坑点在于：</p><ol><li>你的min如果不对book数组中的0进行特别判定的话，那么你会WA；</li><li>一般素数是不会判断0的（没错，我一开始的接口没有判断0），所以我在0卡了好一会儿。<br>代码如下<pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;char memo[105];int book[26];int max(int a, int b) { return a &gt; b ? a : b; }int min(int a, int b) { return a &lt; b ? a : b; }bool Is_Prime(int num) { if (num == 0) return false; if (num == 1) return false; if (num == 2) return true; int bound = sqrt(num); for (int i = 2; i &lt;= bound + 1; i++) {     if (num % i == 0)         return false; } return true;}int main() { int mmax = -1, mmin = 999; scanf("%s", memo); int len = strlen(memo); for (int i = 0; i &lt; len; i++) book[memo[i] - 'a']++; for (int i = 0; i &lt; 26; i++) {     mmax = max(mmax, book[i]);     if (book[i] == 0)  continue;     else mmin = min(mmin, book[i]); } if (Is_Prime(mmax - mmin)) return 0 * printf("Lucky Word\n%d\n", mmax - mmin); else return 0 * printf("No Answer\n0\n");}</code></pre><h2 id="题目3：口算计算题"><a href="#题目3：口算计算题" class="headerlink" title="题目3：口算计算题"></a>题目3：口算计算题</h2>根据题目进行模拟即可，但是这里有个重点是如何区分三个还是两个的情况（所以这题的难度真的是普及-吗？）。<br>具体实现方式见代码和注释。<pre><code>#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int Num_lenth(int num){ int len = 0; if (num &lt; 0 || num == 0) len++; while (num) len++, num /= 10; return len;}int To_num(string s){ int ans = 0, len = s.size(); for (int i = 0; i &lt; len; i++) ans = ans * 10 + s[i] - '0'; return ans;}int main(){ string sa, sb; int a, b, n; char ch, copy; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++){     cin &gt;&gt; ch &gt;&gt; sa &gt;&gt; sb;      if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') sa = ch + sa, ch = copy;//因为第一个不是字母，所以我们把copy赋予ch方便后续判断     //string类加法就是拼接字符串,copy是上一轮的字符。     a = To_num(sa), b = To_num(sb);       //本来打算用atoi但是因为是string就得手造轮子     int a_len = Num_lenth(a), b_len = Num_lenth(b);     if (ch == 'a') printf("%d+%d=%d\n%d", a, b, a + b, a_len + b_len + 2 + Num_lenth(a + b)), copy = ch;     else if (ch == 'b') printf("%d-%d=%d\n%d", a, b, a - b, a_len + b_len + 2 + Num_lenth(a - b)), copy = ch;     else if (ch == 'c') printf("%d*%d=%d\n%d", a, b, a * b, a_len + b_len + 2 + Num_lenth(a * b)), copy = ch;     if (i &lt; n) cout &lt;&lt; endl;     //这里注意，多输出换行爆0 } return 0;}</code></pre><h2 id="题目4：标题统计"><a href="#题目4：标题统计" class="headerlink" title="题目4：标题统计"></a>题目4：标题统计</h2>假如你是顺序做题的话，经历了上面的题的洗礼，这道题简直就是送分题，但是，这里科普一下：gets函数请勿在比赛的时候使用（C11以上已经不允许使用了）。<pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ char s[10]; int ans = 0, len; fgets(s, 10, stdin); len = strlen(s); for (int i = 0; i &lt; len; i++) {                       if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') ans++;     if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') ans++;     if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') ans++; } return 0 * printf("%d\n", ans);}</code></pre><h2 id="题目5：文字处理软件"><a href="#题目5：文字处理软件" class="headerlink" title="题目5：文字处理软件"></a>题目5：文字处理软件</h2>按照题目使用库函数即可（自己写费时费力）<pre><code>#include&lt;cstdio&gt;#include&lt;cstring&gt;const int MAXN = 105;char text[MAXN], temp[MAXN];int main(){ int n, op, a, b; scanf("%d\n%s", &amp;n, text); for (int i = 1; i &lt;= n; i++) {     scanf("%d", &amp;op);     if (op == 1) {         scanf("%s", temp);         strcat(text, temp);         printf("%s\n", text);     }     else if (op == 2) {         scanf("%d %d", &amp;a, &amp;b);         text[a + b] = '\0';         strcpy(temp, text + a);         strcpy(text, temp);         printf("%s\n", text);     }     else if (op == 3) {         scanf("%d %s", &amp;a, temp);         strcat(temp, text + a);         text[a] = '\0';         strcat(text, temp);         printf("%s\n", text);     }     else {         scanf("%s", temp);         char* ans = strstr(text, temp);         if (ans != NULL) printf("%d\n", int(ans - text));         else printf("-1\n");     } } return 0;}</code></pre><h2 id="题目6：统计单词数"><a href="#题目6：统计单词数" class="headerlink" title="题目6：统计单词数"></a>题目6：统计单词数</h2>按照题目要求，请勿使用cin因为cin无法读入空格，这里提供另外一个思路，循环到文件结尾，将文章的每个单词读入string中，然后处理都为大写或者小写，直接strcmp每个string(这里就不写咯）。<pre><code>#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int main(){ string article, word; int pass_len, word_len, t = 0, pos = 0, j; getline(cin, word), getline(cin, article); word_len = word.size(), pass_len = article.size(); for (int i = 0; i &lt; word_len; i++) word[i] = toupper(word[i]); //不采用-'a'+'A'的方式主要是需要多写一个判断其是不是属于'a'到'z'之间 for (int i = 0; i &lt; pass_len; i++) article[i] = toupper(article[i]); for (int i = 0; i &lt;= pass_len - word_len; i++){     for (j = 0; j &lt; word_len; ++j){         if (article[j + i] != word[j]) break;         if (i &gt; 0 &amp;&amp; article[i - 1] != ' ') break;     }     if (j == word_len &amp;&amp; (article[j + i] == ' ' || j + i == pass_len))          if (++t == 1) pos = i; } if (t == 0) cout &lt;&lt; -1; else cout &lt;&lt; t &lt;&lt; " " &lt;&lt; pos; return 0;}</code></pre><h2 id="题目7：手机"><a href="#题目7：手机" class="headerlink" title="题目7：手机"></a>题目7：手机</h2>由于每个字母需要按的次数是固定的，所以我们打表即可。<pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;int cnt[26] = { 1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4 };int main(){ string s; getline(cin, s); int ans = 0, len = s.length(); for (int i = 0; i &lt; s.length(); i++){     if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') ans += cnt[s[i] - 'a'];     if (s[i] == ' ') ans++; } return 0* printf("%d", ans);}</code></pre><h2 id="题目8：honoka的键盘"><a href="#题目8：honoka的键盘" class="headerlink" title="题目8：honoka的键盘"></a>题目8：honoka的键盘</h2>遍历两次，同时使用book数组来保证’VK’没有被使用，且由于只能变换一次保证最多的VK，因此答案必然是VK的数目或者VK+1。<pre><code>#include&lt;cstdio&gt;using namespace std;int n, ans, flag, book[105];char s[105];int main(){ scanf("%d%s", &amp;n, s); for (int i = 1; i &lt; n; i++)     if (s[i - 1] == 'V' &amp;&amp; s[i] == 'K')         ans++, book[i - 1] = book[i] = 1; for (int i = 1; i &lt; n; i++)     if (!flag &amp;&amp; !book[i - 1] &amp;&amp; !book[i] &amp;&amp; s[i - 1] == s[i])         flag = 1, ans++; return 0 * printf("%d\n", ans);}</code></pre><h2 id="题目9：单词覆盖还原"><a href="#题目9：单词覆盖还原" class="headerlink" title="题目9：单词覆盖还原"></a>题目9：单词覆盖还原</h2>题目含义就是，只要b开头，第二个是o或第三个是y或第二三是oy，那么就算一个boy；girl同理<pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() { int bcnt = 0, gcnt = 0; string s; cin &gt;&gt; s; for (int i = 0; i &lt;= s.length(); i++) {     if (s[i] == 'b' || s[i + 1] == 'o' || s[i + 2] == 'y')bcnt++;     if (s[i] == 'g' || s[i + 1] == 'i' || s[i + 2] == 'r' || s[i + 3] == 'l') gcnt++; } cout &lt;&lt; bcnt &lt;&lt; endl &lt;&lt; gcnt &lt;&lt; endl; return 0;}</code></pre><h2 id="题目10：数字反转（升级版）"><a href="#题目10：数字反转（升级版）" class="headerlink" title="题目10：数字反转（升级版）"></a>题目10：数字反转（升级版）</h2>前面有一个简易版本的数字反转，这个要难一点，但是依旧只要按照题目所说就可以正确做出来（就是细节特别多），这里使用的是栈。<br>没错，细节多到炸，我以为按照题意不会出现1.00100这种数字，结果在这个点疯狂WA，而且还有很多奇形怪状的坑点，调BUG调了40min。<pre><code>#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stack&gt;using namespace std;char memo[30];int main() { stack&lt;char&gt; s; scanf("%s", memo); int len = strlen(memo); int signal_pos = len, zero_flag = 1; for (int i = 0; i &lt; len; i++) if (memo[i] &lt; '0' || memo[i]&gt;'9') signal_pos = i;//非整数 for (int i = 0; i &lt; signal_pos; i++) s.push(memo[i]);//符号前进栈 while (s.size() != 0) {//输出     char temp = s.top();     if (temp != '0') zero_flag = 0;     if (zero_flag == 1);     else cout &lt;&lt; temp;     s.pop(); } if (zero_flag == 1) cout &lt;&lt; 0;//说明符号前整个都是0，只有一个0 cout &lt;&lt; memo[signal_pos];//输出符号或整数的最后一位 zero_flag = 1; for (int i = signal_pos + 1; i &lt; len; i++) {     if (zero_flag == 0) s.push(memo[i]);     else {         if (memo[i] == '0') continue;//原来数据的前导0我们不要         else {             zero_flag = 0;//不是前导0了             s.push(memo[i]);         }     } } if (s.size() == 0 &amp;&amp; signal_pos != len &amp;&amp; signal_pos != len - 1) cout &lt;&lt; 0; //第一个说明小/分数后面是0，第二个说明是整数，第三个说明是百分数 zero_flag = 1; while (s.size() != 0) {//输出     char temp = s.top();     if (temp != '0') zero_flag = 0;     if (zero_flag == 1);     else cout &lt;&lt; temp;     s.pop(); } return 0;}</code></pre><h2 id="题目11：斯诺登的密码"><a href="#题目11：斯诺登的密码" class="headerlink" title="题目11：斯诺登的密码"></a>题目11：斯诺登的密码</h2>这题首先，你得打表，不然你就得写很多很多ifelseif；其次，然后对于平方后取模，建议也直接打表，不然前导0去除很恶心。<pre><code>//先挖个坑，由于环境不一样，所以你直接copy会CE#pragma warning(disable:4996)#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;char dic[30][10] = { "zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty","a","both","another","first","second","third" };int ind[30] = { 0,1,4,9,16,25,36,49,64,81,00,21,44,69,96,25,56,89,24,61,0,1,4,1,1,4,9 },ans[10]; char s[100];int main(){ int pos = 0, flag = 0; for (int i = 0; i &lt; 6; i++){     scanf("%s", s);     for (int j = 0; j &lt; 26; j++){         if (!strcmp(s, dic[j])){             ans[pos++] = ind[j];             break;         }     } } sort(ans, ans + pos); for (int i = 0; i &lt; pos; i++){     if (flag) printf("%.2d", ans[i]);      else{         if (ans[i]){             printf("%d", ans[i]);             flag = 1;         }     } } if (!flag) printf("0"); return 0;}</code></pre><h2 id="题目12：你的飞碟在这里"><a href="#题目12：你的飞碟在这里" class="headerlink" title="题目12：你的飞碟在这里"></a>题目12：你的飞碟在这里</h2>按照题目来，此题没有坑点（早期做的题目，代码懒得重写）。<pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;char st[7],gr[7];int main(){ long long int star,group; int stl,gro; scanf("%s%s",st,gr); star=1,group=1,stl=strlen(st),gro=strlen(gr); for(int i=0;i&lt;stl;i++) star*=(st[i]-'A'+1); star=star%47; for(int i=0;i&lt;gro;i++) group*=(gr[i]-'A'+1); group=group%47; if(star==group) printf("GO"); else printf("STAY"); return 0;}</code></pre><h2 id="题目13：语句解析"><a href="#题目13：语句解析" class="headerlink" title="题目13：语句解析"></a>题目13：语句解析</h2>scanf属于格式输入，使用scanf可以定向输入想要位置的值，然后按照题目要求就可以做了。</li></ol><pre><code>#include&lt;stdio.h&gt;int main(){    int a[3] = { 0,0,0 };    char s1, s2;    while (scanf("%c:=%c;", &amp;s1, &amp;s2) == 2)        if (s2 &gt;= '0' &amp;&amp; s2 &lt;= '9') a[s1 - 'a'] = s2 - '0';        else a[s1 - 'a'] = a[s2 - 'a'];    return 0 * printf("%d %d %d", a[0], a[1], a[2]);}</code></pre><h2 id="题目14：垂直柱状图"><a href="#题目14：垂直柱状图" class="headerlink" title="题目14：垂直柱状图"></a>题目14：垂直柱状图</h2><p>K&amp;R C书籍上的原题，属于比较繁琐的字符串模拟，重点是你要先找到最大的数来决定你要输出的最大范围</p><pre><code>#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int book[26];int max(int x, int y) { return x &gt; y ? x : y ;}int main(){    int n, maxn = -1;;    string a;    for (int i = 0; i &lt; 4; i++){        getline(cin,a);        n = a.length();        for (int j = 0; j &lt; n; j++)            if (a[j] &gt;= 'A' &amp;&amp; a[j] &lt;= 'Z')                book[a[j] - 'A']++;    }    for (int i = 0; i &lt; 26; i++)        maxn = max(maxn, book[i]);    for (int i = maxn; i &gt; 0; i--) {        for (int j = 0; j &lt; 26; j++) {            if (book[j] &gt;= i)printf("* ");            else printf("  ");        }        printf("\n");    }    for (int i = 0; i &lt; 26; i++) printf("%c ", i + 'A');    return 0;}</code></pre><p>今天的字符串入门就是这些啦，内容虽然不难，但题都或多或少的繁琐（考虑多种边界条件），会了基本之后才能为后面更难的字符串题目（字符串的难题基本都得构造出状态机，因此需要很好的基础），一天杀一单子题还是有点刺激。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法题解 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷官方题单——数组题解（部分水题警告）</title>
      <link href="/2020/04/14/luo-gu-guan-fang-ti-dan-shu-zu-ti-jie-bu-fen-shui-ti-jing-gao/"/>
      <url>/2020/04/14/luo-gu-guan-fang-ti-dan-shu-zu-ti-jie-bu-fen-shui-ti-jing-gao/</url>
      
        <content type="html"><![CDATA[<p>今天之后，题目会开始变得困难了一些，但是就现在为止还是抵挡不住我们的刷题节奏。废话不多说，直接开搞。</p><h2 id="题目0：小鱼比可爱"><a href="#题目0：小鱼比可爱" class="headerlink" title="题目0：小鱼比可爱"></a>题目0：小鱼比可爱</h2><p>十分简单，存到一个数组中，然后从0往n-1依次遍历，记录当前位置；然后从0到当前位置遍历，当数字比他小，则cnt++，然后输出cnt和一个空格即可。<br>时间复杂度O(n^2)。</p><pre><code>#define MAXN 105   //这里应该是大家都知道的小技巧了，就是数组稍微开大一些int array[MAXN];      //但是注意不一定开大一些就+5,+50，有些题目会存在开一倍甚至更多的情况（后面就会有体现）int main(){    int n,cnt=0;    scanf("%d",&amp;n);    for(int i=0;i&lt;n;i++) scanf("%d",&amp;array[i]);    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;i;j++) if(array[j]&lt;array[i]) cnt++;        printf("%d ",cnt);        cnt=0;            //毕竟下一轮循环cnt就是新生了    }    return 0;}</code></pre><h2 id="题目1：小鱼的数字游戏"><a href="#题目1：小鱼的数字游戏" class="headerlink" title="题目1：小鱼的数字游戏"></a>题目1：小鱼的数字游戏</h2><p>可以考虑两个办法，一个是开一个stack<int> s;然后存进去再依次输出（栈）。<br>另外一个办法就是记录到一个数组，同时记录个数（因为以0为结尾，所以需要额外记录数字个数），然后从最后往前输出即可。</int></p><pre><code>long long int num[105];   //long long 没必要，但是我就是要加int main() {    int i = 0;    do {scanf("%lld", &amp;num[++i]);} while (num[i] != 0);    for (int j = i - 1; j &gt; 0; j--) printf("%lld ", num[j]);    return 0;}</code></pre><h2 id="题目2：冰雹猜想"><a href="#题目2：冰雹猜想" class="headerlink" title="题目2：冰雹猜想"></a>题目2：冰雹猜想</h2><p>纯粹的模拟题，由于最后需要倒着输出，所以是需要存在一个数组里面的(当然可以利用递归在系统中是需要栈空间的特性来使用递归输出）。</p><pre><code>//递归版本#include&lt;stdio.h&gt;void print(int n){    if(n==1){        printf("1");        return;    }    if(n&amp;1) print(n*3+1);    else print(n&gt;&gt;1);    printf(" %d",n);}int main(){    int n;    scanf("%d",&amp;n);    print(n);    return 0;}//非递归版本，使用栈#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;stack&lt;int&gt; s;int main(){    int n;    scanf("%d",&amp;n);    while(n!=1){        s.push(n);        if(n&amp;1) n&gt;&gt;=1;        else n=n*3+1;    }    printf("1 ");    while(!s.empty()){        int ans=s.top();        printf("%d ",ans);        s.pop();    }    return 0;}//非递归，普通实现#include&lt;stdio.h&gt;int memo[1000];int main() {    int n, cnt = 1;    scanf("%d", &amp;n);    while (n != 1) {        memo[cnt++] = n;        if (n &amp; 1) n = 3 * n + 1;        else n &gt;&gt;= 1;    }    memo[cnt] = 1;    for (int i = cnt; i &gt;= 1; i--) printf("%d ", memo[i]);    return 0;}</code></pre><h2 id="题目3：校门外的树"><a href="#题目3：校门外的树" class="headerlink" title="题目3：校门外的树"></a>题目3：校门外的树</h2><p>按照题目模拟一边即可（线段树/分块啥的暂时就别搞这些花里胡哨的嗷）。</p><pre><code>#include&lt;stdio.h&gt;#define MAXN 10002int path[MAXN];int main(){    int L, M;    int st, en, count;    count = 0;    scanf("%d%d", &amp;L, &amp;M);    for (int i = 0; i &lt;= L; i++) path[i] = 1;    while (M){        scanf("%d%d", &amp;st, &amp;en);        for (int i = st; i &lt;= en; i++) path[i] = 0;        M--;    }    for (int i = 0; i &lt;= L; i++) if (path[i] == 1) count++;    return 0*printf("%d", count);}</code></pre><h2 id="题目4：旗鼓相当的对手"><a href="#题目4：旗鼓相当的对手" class="headerlink" title="题目4：旗鼓相当的对手"></a>题目4：旗鼓相当的对手</h2><p>我这里使用的是结构体，也可以使用二维数组，然后遍历就行了</p><pre><code>#include&lt;stdio.h&gt;typedef struct student {    int Chinese, Math, English, sum;}student;student memo[1005];int abs(int x) { return x &gt;= 0 ? x : -x; }int check(int i, int j) {    return (abs(memo[i].Chinese - memo[j].Chinese) &lt;= 5) &amp;&amp;        (abs(memo[i].Math - memo[j].Math) &lt;= 5) &amp;&amp;        (abs(memo[i].English - memo[j].English)) &lt;= 5 &amp;&amp;        (abs(memo[i].sum - memo[j].sum) &lt;= 10);}int main() {    int n,ans=0;    scanf("%d", &amp;n);    for (int i = 0; i &lt; n; i++) {        scanf("%d%d%d", &amp;memo[i].Chinese, &amp;memo[i].Math, &amp;memo[i].English);        memo[i].sum = memo[i].Chinese + memo[i].Math + memo[i].English;    }    for (int i = 0; i &lt; n; i++)        for (int j = i + 1; j &lt; n; j++)             ans += check(i, j);    return 0 * printf("%d\n", ans);}</code></pre><h2 id="题目5：工艺品制作"><a href="#题目5：工艺品制作" class="headerlink" title="题目5：工艺品制作"></a>题目5：工艺品制作</h2><p>需要使用标记数组book确定这部分切割的地方有没有“蒸发”，然后模拟即可。<br>‘’’<br>#include&lt;stdio.h&gt;<br>const int MAXN = 25;<br>int book[MAXN][MAXN][MAXN];<br>int main() {<br>    int w, x, h, q, ans = 0;<br>    scanf(“%d%d%d%d”, &amp;w, &amp;x, &amp;h, &amp;q);<br>    while (q–){<br>        int x1, y1, z1, x2, y2, z2;<br>        scanf(“%d%d%d%d%d%d”, &amp;x1, &amp;y1, &amp;z1, &amp;x2, &amp;y2, &amp;z2);<br>        for (int i = x1; i &lt;= x2; i++)<br>            for (int j = y1; j &lt;= y2; j++)<br>                for (int k = z1; k &lt;= z2; k++) book[i][j][k] = 1;<br>    }<br>    for (int i = 1; i &lt;= w; i++)<br>        for (int j = 1; j &lt;= x; j++)<br>            for (int k = 1; k &lt;= h; k++)<br>                if (book[i][j][k] == 0) ans++;<br>    return 0 * printf(“%d\n”, ans);<br>}<br>‘’’</p><h2 id="题目6：彩票摇奖"><a href="#题目6：彩票摇奖" class="headerlink" title="题目6：彩票摇奖"></a>题目6：彩票摇奖</h2><p>采用一个数组来确定哪些号码已经被选取，这样在后续可以直接用输入得到的号码当做索引来查看是否买了这个数。</p><pre><code>#include&lt;stdio.h&gt;const int MAXN = 35;int book[MAXN], ans[8];int main() {    int n, temp;    scanf("%d", &amp;n);    for (int i = 0; i &lt; 7; i++) {        scanf("%d", &amp;temp);        book[temp] = 1;    }    for (int i = 0; i &lt; n; i++) {        int cnt = 0;        for (int j = 0; j &lt; 7; j++) {            scanf("%d", &amp;temp);            if (book[temp] == 1) cnt++;        }        ans[cnt]++;    }    for (int i = 7; i &gt;= 1; i--) printf("%d ", ans[i]);    return 0;}</code></pre><h2 id="题目7：幻方"><a href="#题目7：幻方" class="headerlink" title="题目7：幻方"></a>题目7：幻方</h2><p>注意通过取模来达到循环的技巧也是经常使用的（尤其在字符串和循环队列中），其余按照题目一个一个写就行了。</p><pre><code>//取模，此代码来自洛谷的HsKr #include&lt;stdio.h&gt;int n, a[40][40], x, y;int main() {    scanf("%d", &amp;n);    x = 1, y = (n + 1) / 2;    for (int i = 1; i &lt;= n * n; i++) {        a[x][y] = i;        if (a[(x - 2 + n) % n + 1][y % n + 1] == 0) x = (x - 2 + n) % n + 1, y = y % n + 1;        else x = x % n + 1;    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= n; j++)             printf("%d ", a[i][j]);        printf("\n");    }    return 0;}//非取模#include&lt;stdio.h&gt;int ans[40][40];int main() {    int n, x, y;    scanf("%d", &amp;n);    x = 1, y = (n + 1) / 2;    for (int i = 1; i &lt;= n * n; i++) {        ans[x][y] = i;        if (x == 1 &amp;&amp; y != n) x = n, y++;        else if (x != 1 &amp;&amp; y == n) y = 1, x--;        else if (x == 1 &amp;&amp; y == n) y = n, x++;        else if (ans[x - 1][y + 1] == 0) x--, y++;        else x++;    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= n; j++) {            printf("%d ", ans[i][j]);        }        printf("\n");    }}</code></pre><h2 id="题目8：显示屏"><a href="#题目8：显示屏" class="headerlink" title="题目8：显示屏"></a>题目8：显示屏</h2><p>打表题，可以提前将对应的存在一个string<string>（或者string的二维数组）里，然后输入的字符串读一位输出一位，中间加列点。<br>这道例题不放代码，因为打表题代码都是大同小异。</string></p><h2 id="题目9：梦中的统计"><a href="#题目9：梦中的统计" class="headerlink" title="题目9：梦中的统计"></a>题目9：梦中的统计</h2><p>输入开始和结束的数字，遍历一遍并在book数组里面统计对应出现的数即可。</p><pre><code>#include&lt;stdio.h&gt;int main(){    int book[10] = { 0 }, start, end;    scanf("%d%d", &amp;start, &amp;end);    for (int i = start; i &lt;= end; i++)        for (int temp = i; temp != 0; temp /= 10)            book[temp % 10]++;    for (int i = 0; i &lt;= 9; i++)        printf("%d ", book[i]);    return 0;}</code></pre><h2 id="题目10：珠心算测验"><a href="#题目10：珠心算测验" class="headerlink" title="题目10：珠心算测验"></a>题目10：珠心算测验</h2><p>这里有个坑，注意要防止存在重复的（例如1+7=8，2+6=8，3+5=8都是重复的），因此最后的比较只看他是不是为0而不是简单粗暴的加起来。</p><pre><code>#include&lt;stdio.h&gt;#define MAXN 20005int answer[MAXN],book[MAXN],store[105];int main() {    int n;    int cnt = 0;    scanf("%d", &amp;n);    for (int i = 1; i &lt;= n; i++) {        scanf("%d", &amp;store[i]);        book[store[i]] = 1;    }    for (int i = 1; i &lt;= n; i++)        for (int j = i + 1; j &lt;= n; j++)            answer[store[i] + store[j]]++;    for (int i = 1; i &lt; MAXN; i++)        if (book[i] &gt; 0 &amp;&amp; answer[i]) cnt++;    return 0 * printf("%d", cnt);}</code></pre><h2 id="题目11：爱与愁的心痛"><a href="#题目11：爱与愁的心痛" class="headerlink" title="题目11：爱与愁的心痛"></a>题目11：爱与愁的心痛</h2><p>就按照题目要求直接写就行了，我这里相当于构造了一个滑动窗口。</p><pre><code>#pragma warning(disable:4996)#include&lt;stdio.h&gt;int memo[3050];int min(int x, int y) { return x &gt; y ? y : x; }int main() {    freopen("a.in", "r", stdin);    freopen("a.out", "w", stdout);    int n, m, mmin = 1e9, sum = 0;    scanf("%d%d", &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++) scanf("%d", &amp;memo[i]);    for (int i = 0; i &lt; m; i++) sum += memo[i];    if(n==m) return 0 * printf("%d\n", sum);    mmin = min(mmin, sum);    for (int i = m; i &lt; n; i++) {        sum = sum - memo[i - m] + memo[i];        mmin = min(mmin, sum);    }    return 0 * printf("%d\n", mmin);}</code></pre><h2 id="题目12：Bovine-Bones-G"><a href="#题目12：Bovine-Bones-G" class="headerlink" title="题目12：Bovine Bones G"></a>题目12：Bovine Bones G</h2><p>简单的骰子模拟题，直接暴力就行了（数据范围很小，n^3也能接受的）。</p><pre><code>#include&lt;stdio.h&gt;int book[65];int main() {    int s1, s2, s3, K = 0, mmax = -1;    scanf("%d%d%d", &amp;s1, &amp;s2, &amp;s3);    for (int i = 1; i &lt;= s1; i++)         for (int j = 1; j &lt;= s2; j++)             for (int k = 1; k &lt;= s3; k++)                 book[i + j + k]++;    for (int i = 1; i &lt;= s1 + s2 + s3; i++)         if (mmax &lt; book[i]) K = i, mmax = book[i];    return 0 * printf("%d\n", K);}</code></pre><h2 id="题目13：开灯"><a href="#题目13：开灯" class="headerlink" title="题目13：开灯"></a>题目13：开灯</h2><p>这里我们可以将题目视作，寻找数组仅出现过奇数次的题目。由于aXORa=0，开关灯相当于是有两个a，则所有数据异或后只有一个数字就是这个开灯的编号。<br>网络上关于位运算的题目有很多，后续有机会写个blog。</p><pre><code>#pragma warning(disable:4996)#include&lt;stdio.h&gt;int book[65];int main() {    freopen("a.in", "r", stdin);    freopen("a.out", "w", stdout);    int n,t,ans=0;    double a;    scanf("%d", &amp;n);    for (int i = 1; i &lt;= n; i++) {        scanf("%lf%d", &amp;a, &amp;t);        for (int j = 1; j &lt;= t; j++) ans ^= int(j * a);    }    return 0 * printf("%d\n", ans);}</code></pre><h2 id="题目14：蛇形方阵"><a href="#题目14：蛇形方阵" class="headerlink" title="题目14：蛇形方阵"></a>题目14：蛇形方阵</h2><p>这是《算法竞赛入门经典》的最开始的几道例题，十分简单，但是方法有很多，注意天杀的输出格式。</p><pre><code>#include&lt;stdio.h&gt;int memo[10][10];int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };int main() {    int n;    scanf("%d", &amp;n);    for (int x = 0, y = 0, num = 1, d = 0; num &lt;= n * n; num++) {        memo[x][y] = num;        int a = x + dx[d], b = y + dy[d];        if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || memo[a][b] != 0) {//换方向了            d = (d + 1) % 4;            a = x + dx[d], b = y + dy[d];        }        x = a, y = b;    }    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) printf("%3d", memo[i][j]);        printf("\n");    }    return 0;}</code></pre><h2 id="题目15：杨辉三角"><a href="#题目15：杨辉三角" class="headerlink" title="题目15：杨辉三角"></a>题目15：杨辉三角</h2><p>基础递推题，在后面求组合数十分有用。</p><pre><code>#pragma warning(disable:4996)#include&lt;stdio.h&gt;int main() {    int n;    scanf("%d", &amp;n);    int a[22][22] = { 0 };    a[0][0] = 1, a[1][0] = 1, a[1][1] = 1;    for (int i = 2; i &lt; n; i++) {        a[i][0] = 1;        for (int j = 1; j &lt; n - 1; j++) {            a[i][j] = a[i - 1][j - 1] + a[i - 1][j];        }        a[i][i] = 1;    }    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt;= i; j++) {            if (i == j) printf("%d\n", a[i][i]);            else printf("%d ", a[i][j]);        }    }    return 0;}</code></pre><h2 id="题目16：插火把"><a href="#题目16：插火把" class="headerlink" title="题目16：插火把"></a>题目16：插火把</h2><p>具体就按照题目来，十字遍历和方形遍历，最后遍历整个二维数组就可以那些地方会刷怪。</p><pre><code>#include &lt;stdio.h&gt; int map[5005][5005];int abs(int x) { return x &gt;= 0 ? x : -x; }bool check(int x, int y, int n) {    if (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; n) return 0;    return 1;}int main() {    int n, m, k, a, b, ans;    scanf("%d%d%d", &amp;n, &amp;m, &amp;k);     for (int i = 1; i &lt;= m + k; i++) {         scanf("%d%d", &amp;a, &amp;b);         for (int x = -2; x &lt;= 2; x++)            for (int y = -2; y &lt;= 2; y++)                if ((i &gt; m || abs(x) + abs(y) &lt;= 2) &amp;&amp; check(x + a, b + y, n))//i&gt;m就说明是萤石                    map[x + a][b + y]++;    }    for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (map[i][j] == 0) ans++;    return 0 * printf("%d\n", ans);}</code></pre><h2 id="题目17：压缩技术"><a href="#题目17：压缩技术" class="headerlink" title="题目17：压缩技术"></a>题目17：压缩技术</h2><p>按照题目要求暴力做就行了，直接按照一维方式来做，二维反而更麻烦。</p><pre><code>#include&lt;iostream&gt;int book[42000];using namespace std;int main(){    int n, temp, bit = 0, cur = 0, i = 0;    cin &gt;&gt; n;    while (cin &gt;&gt; temp){        for (i = cur; i &lt; cur + temp; i++) book[i] = bit;        cur = i;        bit = !bit;    }    cur = 0;    for (int i = 0; i &lt; n; i++){        for (int j = 0; j &lt; n; j++)            cout &lt;&lt; book[cur++];        cout &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="题目18：压缩技术（续集版）"><a href="#题目18：压缩技术（续集版）" class="headerlink" title="题目18：压缩技术（续集版）"></a>题目18：压缩技术（续集版）</h2><p>存在一个string数组里面，这样就不需要后面求个平方根了，然后遍历每一个string，注意不要在循环内使用局部变量，因为其换行不影响cnt的累计。</p><pre><code>#include &lt;iostream&gt;using namespace std;string memo[205];int main() {    char bit = '0';    int cnt = 0;    cin &gt;&gt; memo[0];    for (int i = 1; i &lt; memo[0].size(); i++) cin &gt;&gt; memo[i];    cout &lt;&lt; memo[0].size() &lt;&lt; " ";    for (int i = 0; i &lt; memo[0].size(); i++) {        for (int j = 0; j &lt; memo[0].size(); j++) {            if (memo[i][j] == bit) cnt++;            else {                bit = memo[i][j];                cout &lt;&lt; cnt &lt;&lt; " ";                cnt = 1;            }        }    }    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;}</code></pre><h2 id="题目19：方块转换"><a href="#题目19：方块转换" class="headerlink" title="题目19：方块转换"></a>题目19：方块转换</h2><p>最后一道可以说是一个搜索，亦可以说是一个模拟，由于代码长度过长，建议直接看洛谷的题解。</p><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>首先对于模拟，只需要对1-7的所有内容写一个接口，然后依次调用，一旦在某个地方返回了true/1就可立即输出这个接口对应的数字。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>如果是用搜索的方式，建议学会剪枝后再继续向下看：<br>1.首先整个数字的变换实际上是不需要完全变换的，我们以1作为例子，在（1）中，（1,1）的位置会变换（1,3），在进行比对的时候如果发现两者不等，直接进入下个接口，不浪费时间。<br>2.同时，我们只需要存储开始和结束，然后使用常数的空间就可以检验是否能够匹配成功。<br>也就是说，搜索可以整个过程减少时空开销，但是，极端情况下，我们是不能减少时间的（由于空间从n^2变为了常数，所以一定是减少的），因为假设都在最后一步才能判断是否正确变换的情况下，那么时间和模拟是一样的。</p><p>以上就这个题单的全部内容啦，突然难度开始微微上调做题速度都慢了不少，明天一定早起早点把新的题单刷完。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法题解 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷官方题单——循环结构题解（水题警告）</title>
      <link href="/2020/04/13/luo-gu-guan-fang-ti-dan-xun-huan-jie-gou-ti-jie-shui-ti-jing-gao/"/>
      <url>/2020/04/13/luo-gu-guan-fang-ti-dan-xun-huan-jie-gou-ti-jie-shui-ti-jing-gao/</url>
      
        <content type="html"><![CDATA[<p>今天虽然还是水题，但是实际上已经有部分需要一定的基础才能做出来。下面是代码和部分解释。</p><h2 id="题目0：找最小值"><a href="#题目0：找最小值" class="headerlink" title="题目0：找最小值"></a>题目0：找最小值</h2><p>这个地方方法很多，主要是因为n太小了导致了其随意做，但是我个人倾向于使用一边读入一边寻找最小值的方法，代码如下。</p><pre><code>    int num,m=9999,temp;    scanf("%d",&amp;num);    for(int i=0;i&lt;num;i++){        scanf("%d",&amp;temp);        m=min(m,temp);    }    return 0*printf("%d\n",m);</code></pre><h2 id="题目1：分类平均"><a href="#题目1：分类平均" class="headerlink" title="题目1：分类平均"></a>题目1：分类平均</h2><p>我们只需要一边读入数据，一边判断他们是否能够满足被k整除，分别记录总和和个数即可，注意输出格式。</p><pre><code>    int n,k,ks=0,kcnt=0,nks=0,nkcnt=0;    scanf("%d%d",&amp;n,&amp;k);    for(int i=1;i&lt;=n;i++){        if(i%k==0) ks+=i,kcnt++;        else nks+=i,nkcnt++;    }    printf("%.1f %.1f",1.0*ks/kcnt,1.0*nks/nkcnt);    return 0;</code></pre><h2 id="题目2：一尺之锤"><a href="#题目2：一尺之锤" class="headerlink" title="题目2：一尺之锤"></a>题目2：一尺之锤</h2><p>按照题目的要求，一边除二一边计算日期就行了。（习惯用位运算，左移一位为除2，右移则为乘2）</p><pre><code>    int n,cnt=0;    scanf("%d",&amp;n);    while(n) n &gt;&gt;= 1,cnt++;    return 0*printf("%d\n",cnt);</code></pre><h2 id="题目3：数字直角三角形"><a href="#题目3：数字直角三角形" class="headerlink" title="题目3：数字直角三角形"></a>题目3：数字直角三角形</h2><p>主要是对输出格式的处理，这里有有个小技巧，使用printf函数的时候采用%0xd的时候，可以在前面补0，x为位数。</p><pre><code>    for(int i = 1;i &lt;= n;i++){        for(int j = 1;j &lt;= n - i + 1;j++)             printf("%02d",cnt++);        printf("\n");    }</code></pre><h2 id="题目4：阶乘的和"><a href="#题目4：阶乘的和" class="headerlink" title="题目4：阶乘的和"></a>题目4：阶乘的和</h2><p>高精度警告，因此这里的难度体现在用C/C++上，各位java选手和python选手请忽略</p><pre><code>#include&lt;iostream&gt;using namespace std;int first[2000], ans[2000];void Add(int* a, int* b) {    int pos = 0;    for (int i = 1; i &lt;= 1000; i++) {        b[i] += a[i] + pos;        pos = b[i] / 10;        b[i] %= 10;    }}void Factorial(int* a, int b) {    int pos = 0;    for (int i = 1; i &lt;= 1000; i++) {        a[i] = a[i] * b + pos;        pos = a[i] / 10;        a[i] %= 10;    }}int main() {    int n, flag = 0;    cin &gt;&gt; n;    first[1] = 1;    for (int i = 1; i &lt;= n; i++) {        Factorial(first, i);//求阶乘        Add(first, ans);//从第一个数加到ans里面    }    for (int i = 1000; i &gt;= 1; i--) {        if (ans[i] != 0) flag = 1;        if (flag) cout &lt;&lt; ans[i];    }    return 0;}</code></pre><h2 id="题目5：计数问题"><a href="#题目5：计数问题" class="headerlink" title="题目5：计数问题"></a>题目5：计数问题</h2><p>算是比较基础的问题，求位数，当然也可以存到一个string数组里面，然后每个都是string，然后直接遍历变求string.strlen()之和。</p><pre><code>#include&lt;stdio.h&gt;int Count(x,num){    int cnt = 0;    while (x){        if (num == (x % 10)) cnt++;        x = x / 10;    }    return cnt;}int main(){    int count = 0;    long int n;    int x;    scanf("%ld%d", &amp;n, &amp;x);    while (n){        count += Count(n, x);        n--;    }    return 0*printf("%d", count);}</code></pre><h2 id="题目6：级数求和"><a href="#题目6：级数求和" class="headerlink" title="题目6：级数求和"></a>题目6：级数求和</h2><p>如果你知道级数求和公式，那么没必要一步一步的来，但是如果你不知道直接循环即可。</p><pre><code>#include&lt;stdio.h&gt;int main(){    long long int n,i = 1;    scanf("%lld", &amp;n);    for (double sum = 0.0; sum &lt;=n; i++)    sum += (1.0 / i);    return 0*printf("%lld\n", i-1);//由于i从1开始取，由种树定理可知最后要-1}</code></pre><h2 id="题目7：金币"><a href="#题目7：金币" class="headerlink" title="题目7：金币"></a>题目7：金币</h2><p>简单的按照题目的药酒</p><pre><code># include &lt;stdio.h&gt;int main(){    int k,cnt=0;    scanf("%d",&amp;k);                   for(int n=1;k-n&gt;=0;k-=n)              cnt+=n*n,n++;                return 0*printf("%d\n",cnt+k*n);//因为循环结束条件为k-n&gt;=0,当k-n小于0的时候，    //说明还留了一部分，所以需要加，当  k-n恰好等于0的时候，经过一轮循环以后，k直    //接变为了0，这个部分就没了。}</code></pre><p>当然也可以按照数列求和地方法，高中老师告诉我们：1^2+2^2…+n^2=n(n+1)(2n+1)/6，1+2+3+…+n=n(n+1)/2。通过这两个就可以反解需要多少天才能达到之后超过，之前不够的天数，最后根据是否满足直接补上就行了，代码这里就不贴了，有兴趣的自己算一下。</p><h2 id="题目8：数列求和"><a href="#题目8：数列求和" class="headerlink" title="题目8：数列求和"></a>题目8：数列求和</h2><p>这上面这么多循环的数列求和了，这里最简单的数列求和就没有讲解必要了吧，题目不允许使用等差数列，那么，我们就选择使用他啦。</p><pre><code>    return 0*printf("%d\n",n*-~n&gt;&gt;1);//这里牵扯到C语言比较细节的地方——计算优先级和位运算，看不懂还是老老实实写n*(n+1)/2吧</code></pre><h2 id="题目9：质数口袋"><a href="#题目9：质数口袋" class="headerlink" title="题目9：质数口袋"></a>题目9：质数口袋</h2><p>题目要求求出最多的质数个数以及求和要在给定的范围以内，所以我们只需要贪心从小到大直接选就vans了。</p><pre><code>int isPrime(int y) {    for(int i=2; i*i&lt;=y; ++i) if(y%i==0) return 0;//这里牵扯到质数的性质，只需要判断小于其自身算数平方根的范围就行了，证明略    return 1;}int main() {    int n,x;    long long sum=0;    scanf("%d",&amp;n);    if(n&lt;2) return 0*printf("0\n");    else if(n==2) return 0*printf("2\n1\n");    for(int i=2; i&lt;=n; ++i) {        if(i%2==0&amp;&amp;i!=2) continue;        if(sum+i&gt;n) return 0*printf("%d\n",x);        if(isPrime(i)) {            printf("%d\n",i);            sum+=i;            x++;        }    }    return 0;}</code></pre><h2 id="题目10：回文质数"><a href="#题目10：回文质数" class="headerlink" title="题目10：回文质数"></a>题目10：回文质数</h2><p>按照题目要求，只需要从给定数字最近的一个质数开始就行了。</p><pre><code>#pragma warning(disable:4996)//这个是在VS下不适用scanf_s的时候需要增加的宏定义，一般来说交题可以删掉，我忘了#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;bool book[10000050];//标记即可void Is_Prime(int b) {    memset(book+2, true, sizeof(bool) * 10000048);    int n = sqrt(b);    for (int i = 2; i &lt;= n; i++) if (book[i]) for (int j = 2; j &lt;= b / i; j++) book[i * j] = false;}bool Is_Palindromes(int num) {    int temp = num, ans = 0;    while (temp != 0) ans = ans * 10 + temp % 10, temp /= 10;    return ans == num;}int main() {    int a, b;    scanf("%d%d", &amp;a, &amp;b);    if (b &gt;= 10000000) b = 9999999;//这里的原因是，牛逼“网友”证明得到，没有九位数的回文质数    Is_Prime(b);    if (a % 2 == 0) a++;    for (int i = a; i &lt;= b; i += 2) //这里的原因是因为，除了2，质数都不是偶数        if (book[i] &amp;&amp; Is_Palindromes(i)) printf("%d\n",i);    return 0;}</code></pre><h2 id="题目11：小玉在游泳"><a href="#题目11：小玉在游泳" class="headerlink" title="题目11：小玉在游泳"></a>题目11：小玉在游泳</h2><p>注意数据输入，计算过程和输出的要求格式。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){    double x,sum=0;    int i;    scanf("%lf",&amp;x);    for(i=0;sum&lt;x;i++) sum+=2*pow(0.98,i);    return 0*printf("%d",i);}</code></pre><h2 id="题目12：数字反转（弱小版本）"><a href="#题目12：数字反转（弱小版本）" class="headerlink" title="题目12：数字反转（弱小版本）"></a>题目12：数字反转（弱小版本）</h2><p>有弱小必有加强，后面是有一个加强版本的，这里只需要注意前导0的存在就行了。</p><pre><code>    int num;    int ans = 0;    scanf("%d", &amp;num);    while (num) ans = ans * 10 + num % 10,num /= 10;    return 0 * printf("%d",ans);</code></pre><h2 id="题目13：月落乌啼算钱"><a href="#题目13：月落乌啼算钱" class="headerlink" title="题目13：月落乌啼算钱"></a>题目13：月落乌啼算钱</h2><p>如果你熟悉斐波那契数列，那么对于其解析式一定特别的熟悉，这道题的题干也给了很多的提示，同时fib数列也是理解和深入dp的一个重要入门手段。</p><pre><code>    long long int f[50];    int n;    f[0]=0,f[1]=1,f[2]=1;    scanf("%d",&amp;n);    for (int i=3;i&lt;=n;i++) f[i]=f[i-1]+f[i-2];    return 0*printf("%lld.00",f[n]); //题目毕竟要保证这个式子不能让人一下看出来就是整数嘛</code></pre><h2 id="题目14：求极差"><a href="#题目14：求极差" class="headerlink" title="题目14：求极差"></a>题目14：求极差</h2><p>一边输入一边保存最大最小值即可。</p><pre><code>int main(){    int min=99999,max=-999999,num,temp;    scanf("%d",&amp;num);    for(int i=0;i&lt;num;i++){        scanf("%d",&amp;temp);        max=(max&gt;temp?max:temp);        min=(min&lt;temp?min:temp);    }    return 0*printf("%d\n",max-min);}</code></pre><h2 id="题目15：最长连号"><a href="#题目15：最长连号" class="headerlink" title="题目15：最长连号"></a>题目15：最长连号</h2><p>我这里嫌一边输入一边记录麻烦，所以直接采用的是先全部存下来，然后直接进行遍历。</p><pre><code>#include&lt;stdio.h&gt;int memo[15000];int main() {    int num, ans = -1, temp_ans = 1;    scanf("%d", &amp;num);    if (num == 1) return 0 * printf("1\n");    for (int i = 0; i &lt; num; i++) scanf("%d", &amp;memo[i]);    for (int i = 0; i &lt; num; i++) {        if (memo[i] + 1 == memo[i + 1]) temp_ans++;        else temp_ans = 1;        ans = (ans &gt; temp_ans ? ans : temp_ans);    }    return 0 * printf("%d\n", ans);}</code></pre><h2 id="题目16：质因数分解"><a href="#题目16：质因数分解" class="headerlink" title="题目16：质因数分解"></a>题目16：质因数分解</h2><p>由唯一分解定理可知：一个数能且仅能分解为一组若干质数的乘积，这里给出来的数据是一定是两个质数的乘积，只需要从小到大依次除，当能够除尽的时候，直接输出另一个数就行了</p><pre><code>for (int i = 2; i &lt;= num; i++)         if (num % i == 0) return 0 * printf("%d\n", num / i);</code></pre><h2 id="题目17：求三角形"><a href="#题目17：求三角形" class="headerlink" title="题目17：求三角形"></a>题目17：求三角形</h2><p>输入输出题，前导0的补充方式在前面有，这里不赘述。</p><pre><code>    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) printf("%02d", start++);        printf("\n");    }    printf("\n");    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            if (j + i + 1 &lt; n) printf("  ");            else printf("%02d", sstart++);        }        printf("\n");    }</code></pre><h2 id="题目18：打分"><a href="#题目18：打分" class="headerlink" title="题目18：打分"></a>题目18：打分</h2><p>求最低最高，在数据比较多的情况可以使用极差那道题的方式，但是这里我采用的是使用sort函数，虽然会慢一些，但是代码更加精简。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int memo[1005];int main() {    int n,sum=0;    scanf("%d", &amp;n);    for (int i = 0; i &lt; n; i++) scanf("%d", &amp;memo[i]);    std::sort(memo, memo + n);//你也可以在前面使用名称空间    for (int i = 1; i &lt; n - 1; i++) sum += memo[i];    return 0 * printf("%.2lf\n", sum * 1.0 / (n - 2));}</code></pre><h2 id="题目19：Davor"><a href="#题目19：Davor" class="headerlink" title="题目19：Davor"></a>题目19：Davor</h2><p>因为每个周一到周日所筹集的钱是一样的，所以把钱的总额直接就加起来就行了。</p><pre><code>    for (k = 1;; ++k)        for (x = 100; x &gt; 0; --x)            if ((7 * x + 21 * k) * 52 == n)                 return 0*printf("%d\n%d\n", x, k);</code></pre><h2 id="题目20：津津的储蓄计划"><a href="#题目20：津津的储蓄计划" class="headerlink" title="题目20：津津的储蓄计划"></a>题目20：津津的储蓄计划</h2><p>实际上按照题目要求从1月到12月遍历一次即可。</p><pre><code>#include&lt;stdio.h&gt;int main(){    int a[12],re = 0,c,st = 0;//re即remain剩余，st即store存储，c为consume消耗后还有的整百部分    for (int i = 0; i &lt; 12; i++)  scanf("%d", &amp;a[i]);    for (int i = 0; i&lt;12; i++){        c = (re + 300 - a[i] )/ 100;        re = re + 300 - a[i] - c * 100;        st =st+ c * 100;        if (re&lt;0){//这里说明剩下的钱不够了                i++;                printf("-%d\n", i);                break;            }    }    if (re&gt;0) printf("%d\n", st*120/100 + re);    return 0;}</code></pre><p>以上就是本篇的全部内容啦，如果有问题的话可直接联系我的QQ（在下方可以加）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法题解 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷官方题单——分支结构题解（水题警告）</title>
      <link href="/2020/04/11/luo-gu-guan-fang-ti-dan-fen-zhi-jie-gou-ti-jie-shui-ti-jing-gao/"/>
      <url>/2020/04/11/luo-gu-guan-fang-ti-dan-fen-zhi-jie-gou-ti-jie-shui-ti-jing-gao/</url>
      
        <content type="html"><![CDATA[<p>依旧水题警告，不多BB，直接上。</p><h2 id="题目0：数的性质"><a href="#题目0：数的性质" class="headerlink" title="题目0：数的性质"></a>题目0：数的性质</h2><p>实际上就是简单的与（&amp;），或（|）以及条件复合的基本用法。</p><pre><code>    scanf("%d", &amp;x);    bool a = !(x &amp; 1), b = (x &gt; 4 &amp;&amp; x &lt;= 12);   //a表示题目性质1，b表示题目性质2    printf("%d %d %d %d", a &amp; b, a | b, (a &amp;&amp; !b || b &amp;&amp; !a), !a &amp;&amp; !b);</code></pre><h2 id="题目1：闰年判断"><a href="#题目1：闰年判断" class="headerlink" title="题目1：闰年判断"></a>题目1：闰年判断</h2><p>实际上注意整百年的情况，整百年的情况下必须是400的倍数才可以。原因自行百度嗷。</p><pre><code>    printf("%d\n",(n%4==0&amp;&amp;n%100!=0)||(n%400==0));</code></pre><h2 id="题目2：Apples"><a href="#题目2：Apples" class="headerlink" title="题目2：Apples"></a>题目2：Apples</h2><p>简单的输入输出，只要你具备基本的英语知识（apple的复数形式为apples）</p><pre><code>    if(n&lt;=1) return 0*printf("Today, I ate %d apple.",n);    else return 0*printf("Today, I ate %d apples.",n);</code></pre><h2 id="题目3：洛谷团队系统"><a href="#题目3：洛谷团队系统" class="headerlink" title="题目3：洛谷团队系统"></a>题目3：洛谷团队系统</h2><p>设题目为n，则本地配置需要5n，而上传则为3n+11，令5n&gt;3n+11有n&gt;5.5，因此直接判断</p><pre><code>    if((n*1.0)&gt;5.5) return 0*printf("Luogu\n");    else return 0*printf("Local\n");</code></pre><h2 id="题目4：肥胖问题"><a href="#题目4：肥胖问题" class="headerlink" title="题目4：肥胖问题"></a>题目4：肥胖问题</h2><p>即BMI的计算方法- -，顺带一提，疫情过后各位的BMI怎么样了鸭（滑稽），另外由于题目要求有效数字，所以最好是采用cout输出。</p><pre><code>    double m, h, bmi;    cin &gt;&gt; m &gt;&gt; h;    bmi = m / (h * h);    if (bmi &lt; 18.5) cout &lt;&lt; "Underweight" &lt;&lt; endl;    if (bmi &gt;= 18.5 &amp;&amp; bmi &lt; 24)        cout &lt;&lt; "Normal";    if (bmi &gt;= 24)        cout &lt;&lt; bmi &lt;&lt; endl &lt;&lt; "Overweight" &lt;&lt; endl;</code></pre><h2 id="题目5：三位数排序"><a href="#题目5：三位数排序" class="headerlink" title="题目5：三位数排序"></a>题目5：三位数排序</h2><p>这里我用的std::sort，没啥技术含量，直接略过。</p><h2 id="题目6：月份天数"><a href="#题目6：月份天数" class="headerlink" title="题目6：月份天数"></a>题目6：月份天数</h2><p>运用的打表的方法，对于大部分人来说都是基操。</p><pre><code>int M[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; //提前打个表int main(){    int year,month;    scanf("%d%d",&amp;year,&amp;month);    if((year%4==0&amp;&amp;year%100!=0)||year%400==0) M[2]=29;    return 0*printf("%d\n",M[month]);}</code></pre><h2 id="题目7：不高兴的津津"><a href="#题目7：不高兴的津津" class="headerlink" title="题目7：不高兴的津津"></a>题目7：不高兴的津津</h2><p>直接边读边比较就行了，这道题过水。</p><pre><code>    for (i=0;i&lt;7;i++){        scanf("%d%d",&amp;a,&amp;b);        s=a+b;        if ((s&gt;max)&amp;&amp;(s&gt;8)) max=s,day=i    }    printf("%d",day);    </code></pre><h2 id="题目8：买铅笔"><a href="#题目8：买铅笔" class="headerlink" title="题目8：买铅笔"></a>题目8：买铅笔</h2><p>表示这道题是我早期做的一道题了，题解看看就完事。</p><pre><code>#include&lt;stdio.h&gt;int main(){   int n, n1, p1, n2, p2, n3, p3, a1, a2, a3, fir=0, sec=0, thi=0;   scanf("%d%d%d%d%d%d%d", &amp;n,&amp; n1,&amp;p1, &amp;n2, &amp;p2,&amp; n3,&amp; p3);//早期写法这样太蠢了，不适合拓展   a1 = ((n - 1 + n1) / n1)*p1, a2 = ((n - 1 + n2) / n2)*p2, a3 = ((n - 1 + n3) / n3)*p3;   if (a1 &gt; a2) {      if (a1 &gt; a3){         fir = a1;         if (a2 &gt; a3) sec = a2,thi = a3;         else sec = a3,thi = a2;      }      else fir = a3,sec = a1,thi = a2;   }   else {         if (a2 &gt; a3){             fir = a2;              if (a1 &gt; a3) sec = a1,thi = a3;             else sec = a3,thi = a1;         }      else fir = a3,sec = a2, thi = a1;   }    return 0*printf("%d", thi);}</code></pre><h2 id="题目9：ISBN"><a href="#题目9：ISBN" class="headerlink" title="题目9：ISBN"></a>题目9：ISBN</h2><p>比较暴力的方法，详见代码。</p><pre><code>#include&lt;stdio.h&gt;char a[11];int main(){    char t1, t2;    int check=0;    scanf("%c-%c%c%c-%c%c%c%c%c-%c",&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4],&amp;a[5],&amp;a[6],&amp;a[7],&amp;a[8],&amp;t1);    for(int i=0;i&lt;9;i++) check+= (i+1)*(a[i]-'0');//题解一里面有相关的解释    t2=check%11+'0';    if(t2=='0'+10) t2='X';    if(t1==t2) printf("Right");    else printf("%c-%c%c%c-%c%c%c%c%c-%c",a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],t2);    return 0;}</code></pre><h2 id="题目10：电费"><a href="#题目10：电费" class="headerlink" title="题目10：电费"></a>题目10：电费</h2><p>就是简单粗暴的分段函数desu。</p><pre><code>    if(d&lt;=150) y=0.4463*d;    else if(d&gt;150&amp;&amp;d&lt;=400) y=0.4463*150+0.4663*(d-150);    else y=0.4463*150+0.4663*250+(d-400)*0.5663;    printf("%.1lf",y);//一位小数</code></pre><h2 id="题目11：小鱼的航程"><a href="#题目11：小鱼的航程" class="headerlink" title="题目11：小鱼的航程"></a>题目11：小鱼的航程</h2><p>具体的变量含义见注释。</p><pre><code>   int x, b, c, d;   long int n, a;   scanf("%d%ld", &amp;x, &amp;n);   b = n / 7;    //计算要多少个整周   a = b * 250 * 5;//a表示的是答案，整周直接提前计算   c = n - 7 * b;//还剩下了几天   d = x;//从周几开始天开始   while (c){      if (d == 7) d = 1;//加入这周是周天，那么我们直接让他下一天变为周一      else if (d &lt;= 5) d++, a = a + 250;//工作日，给我游      else d++;//表示周六的时候，不游      c--;//剩余日期减1   }   return 0*printf("%ld", a);</code></pre><h2 id="题目12-：三角函数"><a href="#题目12-：三角函数" class="headerlink" title="题目12 ：三角函数"></a>题目12 ：三角函数</h2><p>由于是勾股数，故两个角都是锐角，正弦函数在(0,pi/2)的范围内随角度增加而增加，故较小锐角的正弦值为最小值/最大值，因此难点变为了约分，这里通过gcd来求解。</p><pre><code>    int a[4];    for (int i=0;i&lt;3;i++) cin&gt;&gt;a[i];    sort(a,a+3);     cout&lt;&lt;a[0]/__gcd(a[0],a[2])&lt;&lt;'/'&lt;&lt;a[2]/__gcd(a[0],a[2]);    return 0;</code></pre><h2 id="题目13：淘淘摘苹果"><a href="#题目13：淘淘摘苹果" class="headerlink" title="题目13：淘淘摘苹果"></a>题目13：淘淘摘苹果</h2><p>提前存好遍历一遍就行了，主要是因为高度在最后才输入，因此不能边输入边cnt++。</p><pre><code>   int a[10],int heigh,can,count=0;   for(int i=0;i&lt;10;i++) scanf("%d", &amp;a[i]);   scanf("%d", &amp;heigh);   can = heigh + 30;   for (int i = 0; i &lt; 10; i++) if (a[i] &lt;= can) count++;   return 0*printf("%d", count);</code></pre><h2 id="题目14：三角形分类"><a href="#题目14：三角形分类" class="headerlink" title="题目14：三角形分类"></a>题目14：三角形分类</h2><p>直接就是三角形判断。</p><pre><code>    scanf("%d%d%d", &amp;a, &amp;b, &amp;c);    int d[4] = {0, a, b, c};//直接放在scanf输入也可以的，这里是懒= =    sort(d + 1, d + 4);    if(d[1] + d[2] &lt;= d[3]) return 0*printf("Not triangle\n");    if(d[1] * d[1] + d[2] * d[2] == d[3] * d[3])    printf("Right triangle\n");    else if(d[1] * d[1] + d[2] * d[2] &gt; d[3] * d[3])    printf("Acute triangle\n");    else if(d[1] * d[1] + d[2] * d[2] &lt; d[3] * d[3])    printf("Obtuse triangle\n");    if(a == b || b == c || a == c)  printf("Isosceles triangle\n");    if(a == b &amp;&amp; b == c)    printf("Equilateral triangle\n");    return 0;</code></pre><h2 id="题目15：ABC"><a href="#题目15：ABC" class="headerlink" title="题目15：ABC"></a>题目15：ABC</h2><p>按照规定的顺序输出三个数字，具体代码见下。</p><pre><code>    int a[3];    char A,B,C;    cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2];    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;    sort(a,a+3);    cout&lt;&lt;a[A-'A']&lt;&lt;" "&lt;&lt;a[B-'A']&lt;&lt;" "&lt;&lt;a[C-'A'];//通过求差来保证ABC的输出顺序    return 0;</code></pre><p>水题基本上没了，后面的题开始会有一点点难度了，欢乐水题就此结束。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法题解 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷官方题单——顺序结构题解（超级水题警告）</title>
      <link href="/2020/04/10/luo-gu-guan-fang-ti-dan-shun-xu-jie-gou-ti-jie-chao-ji-shui-jing-gao/"/>
      <url>/2020/04/10/luo-gu-guan-fang-ti-dan-shun-xu-jie-gou-ti-jie-chao-ji-shui-jing-gao/</url>
      
        <content type="html"><![CDATA[<p>最近洛谷直接更新之前的试炼场模式，现在直接就采用题单了，虽然题目多了不少，但是实际上就是把类似于EX之类的放在了一起，虽然题目多，但是感觉在后面可能会导致一个题单难度会存在飞跃。<br>这是第一期水题集锦，我尽量一日到两日更。另外我记得某本书告诉我们，没有循环的题目实际上某种意义上不适合作为计算机程序，这些题基本上都是这种情况。</p><h2 id="题目0：P1001-A-B"><a href="#题目0：P1001-A-B" class="headerlink" title="题目0：P1001 A+B"></a>题目0：P1001 A+B</h2><p>题解花里胡哨过于多，我也不玩那些了。</p><pre><code>    int a,b;    scanf("%d%d",&amp;a,&amp;b);    printf("%d",a+b);</code></pre><h2 id="题目1：P1000"><a href="#题目1：P1000" class="headerlink" title="题目1：P1000"></a>题目1：P1000</h2><p>输入输出题目，复制粘贴即可，略过</p><h2 id="题目2：苹果采购"><a href="#题目2：苹果采购" class="headerlink" title="题目2：苹果采购"></a>题目2：苹果采购</h2><pre><code>    int a,b;    scanf("%d%d",&amp;a,&amp;b);    return 0*printf("%d\n",a*b);</code></pre><h2 id="题目3：大小写转换"><a href="#题目3：大小写转换" class="headerlink" title="题目3：大小写转换"></a>题目3：大小写转换</h2><p>这算是一个技巧了，而且后面字符串也有类似的操作的</p><pre><code>    printf("%c\n",a-'a'+'A');</code></pre><h2 id="题目4：数字反转"><a href="#题目4：数字反转" class="headerlink" title="题目4：数字反转"></a>题目4：数字反转</h2><p>通过string方式反向输出即可，反正不会像一些题一样跑出来前导0。（也可以用栈）</p><pre><code>    string s,ans="";    cin&gt;&gt;s;    int len=s.length();    for(int i=len-1;i&gt;=0;i--) ans+=s[i];    cout&lt;&lt;ans&lt;&lt;endl;</code></pre><h2 id="题目5：再分肥宅水"><a href="#题目5：再分肥宅水" class="headerlink" title="题目5：再分肥宅水"></a>题目5：再分肥宅水</h2><p>注意输出格式<br>这里是3位小数，而且有这种情况下的要求，建议都用printf</p><pre><code>    printf("%.3lf\n%d",t/n,n*2)</code></pre><h2 id="题目6：小鱼游泳时间"><a href="#题目6：小鱼游泳时间" class="headerlink" title="题目6：小鱼游泳时间"></a>题目6：小鱼游泳时间</h2><p>实际上就是种树问题放在时间上，n段路需要n+1的树，这里计算的时候也要注意；<br>然后分钟可以参考补码的计算方式。补码的情况就是在最大的时候变为最小，所以d+60-b</p><pre><code>    int a, b,c ,d,e,f;//这里都是题目上的字母，不再阐述    scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);    if( d - b &lt; 0 ) e = c - a -1 ,f = d + 60 -b;    else e= c - a, f = d - b;    return 0 * printf("%d %d" , e, f );</code></pre><h2 id="题目7：n合1"><a href="#题目7：n合1" class="headerlink" title="题目7：n合1"></a>题目7：n合1</h2><p>第三题：注意有效数字和小数，cout的方式这样（一般别这么玩）；<br>第五题：行程问题（来自于某小学奥数老师的科普）：相遇问题：路程和=时间×速度和， 火车过桥问题：总路程=车长+桥长，代入公式计算就是15啦<br>第六题：勾股定理（这个大家都不会不知道吧，不会吧不会吧）<br>第九题：这个题就是还原的过程<br>第十题：牛吃草问题（一片草原P，每天增长Q：X牛吃Y天，Z牛吃W天）：在这道题对应之后带进去就可以得到以下方程（我latex还不怎么会用在这里，后期再改）<br>P+30Q=30（即Y）×8（即X）<br>P+6Q=6（即W）×10（即Z）<br>接下来P=15，Q=7.5，即P=P/10（十分钟）+Q=9，即得到了答案（小学生太难了）；<br>第11题：追及问题（依旧来自于某小学奥数老师）：路程变化量：速度变化量=需要的时间</p><pre><code>if (T == 1) {        cout &lt;&lt; "I love Luogu!";    } else if (T == 2) {        cout &lt;&lt; 2 + 4 &lt;&lt; " " &lt;&lt; 10 - 2 - 4;    } else if (T == 3) {        cout&lt;&lt;3&lt;&lt;endl&lt;&lt;12&lt;&lt;endl&lt;&lt;2&lt;&lt;endl;    } else if (T == 4) {        printf("%.3lf\n",500.0/3.0);   //不嫌麻烦可以 cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;1.0*500/3;    } else if (T == 5) {        cout&lt;&lt;15&lt;&lt;endl;    } else if (T == 6) {        cout&lt;&lt;sqrt(6*6+9*9)&lt;&lt;endl;    } else if (T == 7) {        cout&lt;&lt;110&lt;&lt;endl&lt;&lt;90&lt;&lt;endl&lt;&lt;0&lt;&lt;endl;    } else if (T == 8) {        double const pi=3.141593;        double const r=5;        cout&lt;&lt;pi*r*2&lt;&lt;endl&lt;&lt;pi*r*r&lt;&lt;endl&lt;&lt;4.0/3*pi*r*r*r&lt;&lt;endl;    } else if (T == 9) {        cout&lt;&lt;22&lt;&lt;endl;    } else if (T == 10) {        cout&lt;&lt;9&lt;&lt;endl;    } else if (T == 11) {        cout&lt;&lt;100.0/(8-5)&lt;&lt;endl;    } else if (T == 12) {        cout&lt;&lt;13&lt;&lt;endl&lt;&lt;"R"&lt;&lt;endl;    } else if (T == 13) {        double const pi=3.141593;        double V=pi*4*4*4*4/3+pi*10*10*10*4/3;        cout&lt;&lt;floor(pow(V,1.0/3))&lt;&lt;endl;    } else if (T == 14) {        cout&lt;&lt;50&lt;&lt;endl;    }</code></pre><h2 id="题目8：三角形面积"><a href="#题目8：三角形面积" class="headerlink" title="题目8：三角形面积"></a>题目8：三角形面积</h2><p>海伦公式建议加入模板</p><pre><code>    ans=sqrt(p*(p-a)*(p-b)*(p-c));    return 0*printf("%.1lf\n",ans);</code></pre><h2 id="题目9：买铅笔"><a href="#题目9：买铅笔" class="headerlink" title="题目9：买铅笔"></a>题目9：买铅笔</h2><p>这个，转成整数就好了</p><pre><code>  printf("%d",(int)((a*10+b)/19));//a元b角</code></pre><h2 id="题目10：还有几个苹果"><a href="#题目10：还有几个苹果" class="headerlink" title="题目10：还有几个苹果"></a>题目10：还有几个苹果</h2><p>坑有点恶心（也不是恶心，需要考虑下日常），半个不是一个，负数不存在最小为0</p><pre><code>#include&lt;stdio.h&gt;int main(){    int m,t,s,ans;//字母和题目一个要求    scanf("%d%d%d",&amp;m,&amp;t,&amp;s);    if(t==0) return 0*printf("0\n");    ans=m-s/t;    if(ans&lt;0) return 0*printf("0\n");    else{        if(s%t==0) return 0*printf("%d\n",ans);        else return 0*printf("%d\n",ans-1);    } }</code></pre><h2 id="题目11：对角线"><a href="#题目11：对角线" class="headerlink" title="题目11：对角线"></a>题目11：对角线</h2><p>说实话我也不知道这道题怎么（哭哭），所以直接抄了官方的题解，代码如下，于是也加入死记硬背套餐了对于我，后续有正式属于我的题解我会更新（咕咕咕）。</p><pre><code>    ans=n*(n-1)/2*(n-2)/3*(n-3)/4;    return 0*printf("%lld\n",ans);</code></pre><p>以上结束。（评论区我还没搞出来23333，虽然我觉得也人会回复我的弱智水题）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法题解 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/2020/04/07/xin-de-kai-shi/"/>
      <url>/2020/04/07/xin-de-kai-shi/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的blog，这是我的第一篇博客，这里进行下自己的规划以及本博客主要分享的东西。</p><h2 id="接下来对自己的规划"><a href="#接下来对自己的规划" class="headerlink" title="接下来对自己的规划"></a>接下来对自己的规划</h2><h3 id="数学方面"><a href="#数学方面" class="headerlink" title="数学方面"></a>数学方面</h3><p>自己的数学还是太差了些，由于自己想要走计算机图形学，因此打算主要学习一下的东西：</p><ol><li>数学分析：作为其他数学学科的基础，而且由于我考研只考了数学二，对数学一中的空间解析几何，曲线曲面积分，旋度梯度啥的都需要认真“复习”一次，也会分享在这个博客中；</li><li>线性代数：线性代数在计算机中实在是过于重要，所以我需要系统的不站在考试角度上学习一次线性代数；</li><li>概率和统计：这个还是需要好好复习一遍的，计算机中概率和统计在相当多的方向中有着重要的左右；</li><li>拓扑学，微分几何等之类的更难的课程。</li></ol><h3 id="计算机方面"><a href="#计算机方面" class="headerlink" title="计算机方面"></a>计算机方面</h3><p>计算机的相关知识也会放在这里，主要有：</p><ol><li>算法题：虽然是个跨考，但是我还是会经常刷算法题练练脑子，当然前期的情况下我可能会放一些水题，后期会删掉，同时会有自己关于算法的学习过程；</li><li>408四门基础课：大家都懂；</li><li>数据库：属于一个计算机工程师必须的理论基础；</li><li>计算机图形学相关内容和文献阅读读后感：毕竟想走的方向在这里。<br>以上的学习内容后期也会逐渐丰富起来，这毕竟只是自己的第一个文章。</li></ol><h3 id="blog优化方面"><a href="#blog优化方面" class="headerlink" title="blog优化方面"></a>blog优化方面</h3><p>现在用的是一个开源的theme，后期还是会进行更多的更改甚至更换，主要是很多bug现在的我无法解决，并且也牵扯到一些底层的问题，后期再慢慢改（画）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 哔哔叨 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
